{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre> <p>hello_jit.void</p>"},{"location":"#macros-plugin-environment","title":"Macros Plugin Environment","text":""},{"location":"#general-list","title":"General List","text":"<p>All available variables and filters within the macros plugin:</p> Variable Type Content extra dict voidc_repo_url = 'https://github.com/voidc-lab/voidc/blob/master' config MkDocsConfig {'config_file_path': '/home/runner/work/try-pages/try-pages/mkdocs.yml', 'site_name': 'Try Pages', 'nav': [{'Welcome to MkDocs': 'index.md'}, {'Strange': ['strange.md']}, {'Tutorial': ['tutorial.md']}, {'Examples': ['examples.md']}], 'pages': None, 'exclude_docs': , 'draft_docs': None, 'not_in_nav': None, 'site_url': 'https://dmitry-borodkin.github.io/try-pages/', 'site_description': None, 'site_author': None, 'theme': Theme(name='material', dirs=['/opt/hostedtoolcache/Python/3.14.3/x64/lib/python3.14/site-packages/material/templates', '/opt/hostedtoolcache/Python/3.14.3/x64/lib/python3.14/site-packages/mkdocs/templates'], static_templates={'sitemap.xml', '404.html'}, name='material', locale=Locale('en'), language='en', direction=None, features=['navigation.tabs', 'navigation.footer'], font={'text': 'Roboto', 'code': 'Roboto Mono'}, icon=None, favicon='img/black_square.svg', palette=[{'scheme': 'default', 'primary': 'white', 'toggle': {'icon': 'material/brightness-4', 'name': 'Switch to dark mode'}}, {'scheme': 'slate', 'primary': 'black', 'toggle': {'icon': 'material/brightness-4', 'name': 'Switch to light mode'}}], logo='img/black_square.svg'), 'docs_dir': '/home/runner/work/try-pages/try-pages/docs', 'site_dir': '/home/runner/work/try-pages/try-pages/site', 'copyright': None, 'google_analytics': None, 'dev_addr': _IpAddressValue(host='127.0.0.1', port=8000), 'use_directory_urls': True, 'repo_url': None, 'repo_name': None, 'edit_uri_template': None, 'edit_uri': None, 'extra_css': ['stylesheets/extra.css'], 'extra_javascript': [], 'extra_templates': [], 'markdown_extensions': ['toc', 'tables', 'fenced_code', 'pymdownx.tilde', 'pymdownx.emoji', 'pymdownx.highlight', 'pymdownx.inlinehilite', 'pymdownx.snippets', 'pymdownx.superfences'], 'mdx_configs': {'pymdownx.highlight': {'anchor_linenums': True, 'line_spans': '__span', 'pygments_lang_class': True}, 'pymdownx.snippets': {'url_download': True}}, 'strict': False, 'remote_branch': 'gh-pages', 'remote_name': 'origin', 'extra': {'voidc_repo_url': 'https://github.com/voidc-lab/voidc/blob/master'}, 'plugins': {'material/search': , 'macros': }, 'hooks': {}, 'watch': [], 'validation': {'nav': {'omitted_files': 20, 'not_found': 30, 'absolute_links': 20}, 'links': {'not_found': 30, 'absolute_links': 20, 'unrecognized_links': 20, 'anchors': 20}}} environment dict system = 'Linux', system_version = '6.14.0-1017-azure', python_version = '3.14.3', mkdocs_version = '1.6.1', macros_plugin_version = '1.5.0', jinja2_version = '3.1.6' plugin LegacyConfig {'module_name': 'main', 'modules': [], 'render_by_default': True, 'force_render_paths': '', 'include_dir': '', 'include_yaml': [], 'j2_block_start_string': '', 'j2_block_end_string': '', 'j2_variable_start_string': '', 'j2_variable_end_string': '', 'j2_comment_start_string': '', 'j2_comment_end_string': '', 'j2_extensions': [], 'on_undefined': 'keep', 'on_error_fail': False, 'verbose': False} git dict status = True, date [datetime], short_commit = '259bcb6', commit = '259bcb6892212bca46514415d01ef8a2d7a2e8ed', tag = '', short_tag = '', author = 'Dmitry Borodkin', author_email = 'borodkin-dn@yandex.ru', committer = 'Dmitry Borodkin', committer_email = 'borodkin-dn@yandex.ru', date_ISO = 'Mon Mar 2 11:58:24 2026 +0300', message = '...', raw = 'commit 259bcb6892212bca46514415d01ef8a2d7a2e8ed\\nAuthor: Dmitry Borodkin \\nDate:   Mon Mar 2 11:58:24 2026 +0300\\n\\n    ...', root_dir = '/home/runner/work/try-pages/try-pages' voidc_repo_url str 'https://github.com/voidc-lab/voidc/blob/master' macros SuperDict context [function], macros_info [function], now [function], fix_url [function] filters dict pretty [function], relative_url [function] filters_builtin dict abs [builtin_function_or_method], attr [function], batch [function], capitalize [function], center [function], count [builtin_function_or_method], d [function], default [function], dictsort [function], e [function], escape [function], filesizeformat [function], first [function], float [function], forceescape [function], format [function], groupby [function], indent [function], int [function], join [function], last [function], length [builtin_function_or_method], list [function], lower [function], items [function], map [function], min [function], max [function], pprint [function], random [function], reject [function], rejectattr [function], replace [function], reverse [function], round [function], safe [function], select [function], selectattr [function], slice [function], sort [function], string [function], striptags [function], sum [function], title [function], trim [function], truncate [function], unique [function], upper [function], urlencode [function], urlize [function], wordcount [function], wordwrap [function], xmlattr [function], tojson [function] navigation Navigation files Files page Page Page(title='Welcome to MkDocs', url='/try-pages/')"},{"location":"#config-information","title":"Config Information","text":"<p>Standard MkDocs configuration information. Do not try to modify.</p> <p>e.g. <code>{{ config.docs_dir }}</code></p> <p>See also the MkDocs documentation on the config object.</p> Variable Type Content config_file_path str '/home/runner/work/try-pages/try-pages/mkdocs.yml' site_name str 'Try Pages' nav list [{'Welcome to MkDocs': 'index.md'}, {'Strange': ['strange.md']}, {'Tutorial': ['tutorial.md']}, {'Examples': ['examples.md']}] pages NoneType None exclude_docs GitIgnoreSpec draft_docs NoneType None not_in_nav NoneType None site_url str 'https://dmitry-borodkin.github.io/try-pages/' site_description NoneType None site_author NoneType None theme Theme Theme(name='material', dirs=['/opt/hostedtoolcache/Python/3.14.3/x64/lib/python3.14/site-packages/material/templates', '/opt/hostedtoolcache/Python/3.14.3/x64/lib/python3.14/site-packages/mkdocs/templates'], static_templates={'sitemap.xml', '404.html'}, name='material', locale=Locale('en'), language='en', direction=None, features=['navigation.tabs', 'navigation.footer'], font={'text': 'Roboto', 'code': 'Roboto Mono'}, icon=None, favicon='img/black_square.svg', palette=[{'scheme': 'default', 'primary': 'white', 'toggle': {'icon': 'material/brightness-4', 'name': 'Switch to dark mode'}}, {'scheme': 'slate', 'primary': 'black', 'toggle': {'icon': 'material/brightness-4', 'name': 'Switch to light mode'}}], logo='img/black_square.svg') docs_dir str '/home/runner/work/try-pages/try-pages/docs' site_dir str '/home/runner/work/try-pages/try-pages/site' copyright NoneType None google_analytics NoneType None dev_addr _IpAddressValue _IpAddressValue(host='127.0.0.1', port=8000) use_directory_urls bool True repo_url NoneType None repo_name NoneType None edit_uri_template NoneType None edit_uri NoneType None extra_css list ['stylesheets/extra.css'] extra_javascript list [] extra_templates list [] markdown_extensions list ['toc', 'tables', 'fenced_code', 'pymdownx.tilde', 'pymdownx.emoji', 'pymdownx.highlight', 'pymdownx.inlinehilite', 'pymdownx.snippets', 'pymdownx.superfences'] mdx_configs dict pymdownx.highlight [dict], pymdownx.snippets [dict] strict bool False remote_branch str 'gh-pages' remote_name str 'origin' extra LegacyConfig {'voidc_repo_url': 'https://github.com/voidc-lab/voidc/blob/master'} plugins PluginCollection material/search [SearchPlugin], macros [MacrosPlugin] hooks dict watch list [] validation Validation {'nav': {'omitted_files': 20, 'not_found': 30, 'absolute_links': 20}, 'links': {'not_found': 30, 'absolute_links': 20, 'unrecognized_links': 20, 'anchors': 20}}"},{"location":"#macros","title":"Macros","text":"<p>These macros have been defined programmatically for this environment (module or pluglets). </p> Variable Type Content context function (obj, var, value, e) <p>Default Mkdocs-Macro: List an object (by default the variables)</p> macros_info function () <p>Test/debug function: list useful documentation on the mkdocs_macro environment.</p> now function () <p>Default Mkdocs-Macro: Get the current time (at the moment of the project build). It returns a datetime object.  Used alone, it provides a timestamp. To get the year use <code>now().year</code>, for the month number  <code>now().month</code>, etc.</p> fix_url function (url, r) <p>If url is relative, fix it so that it points to the docs directory. This is necessary because relative links in markdown must be adapted in html ('img/foo.png' =&gt; '../img/img.png').</p>"},{"location":"#git-information","title":"Git Information","text":"<p>Information available on the last commit and the git repository containing the documentation project:</p> <p>e.g. <code>{{ git.message }}</code></p> Variable Type Content status bool True date datetime datetime.datetime(2026, 3, 2, 11, 58, 24, tzinfo=tzoffset(None, 10800)) short_commit str '259bcb6' commit str '259bcb6892212bca46514415d01ef8a2d7a2e8ed' tag str '' short_tag str '' author str 'Dmitry Borodkin' author_email str 'borodkin-dn@yandex.ru' committer str 'Dmitry Borodkin' committer_email str 'borodkin-dn@yandex.ru' date_ISO str 'Mon Mar 2 11:58:24 2026 +0300' message str '...' raw str 'commit 259bcb6892212bca46514415d01ef8a2d7a2e8ed\\nAuthor: Dmitry Borodkin \\nDate:   Mon Mar 2 11:58:24 2026 +0300\\n\\n    ...' root_dir str '/home/runner/work/try-pages/try-pages'"},{"location":"#page-attributes","title":"Page Attributes","text":"<p>Provided by MkDocs. These attributes change for every page (the attributes shown are for this page).</p> <p>e.g. <code>{{ page.title }}</code></p> <p>See also the MkDocs documentation on the page object.</p> Variable Type Content file File src_uri = 'index.md', src_dir = '/home/runner/work/try-pages/try-pages/docs', dest_dir = '/home/runner/work/try-pages/try-pages/site', use_directory_urls = True, inclusion [InclusionLevel], name = 'index', dest_uri = 'index.html', page [Page], url = './', abs_src_path = '/home/runner/work/try-pages/try-pages/docs/index.md' title str 'Welcome to MkDocs' children NoneType None previous_page NoneType None next_page Page Page(title=[blank], url='/try-pages/strange/') _Page__active bool False update_date str '2026-03-02' canonical_url str 'https://dmitry-borodkin.github.io/try-pages/' abs_url str '/try-pages/' edit_url NoneType None markdown str '# Welcome to MkDocs\\n\\nFor full documentation visit [mkdocs.org](https://www.mkdocs.org).\\n\\n## Commands\\n\\n* `mkdocs new [dir-name]` - Create a new project.\\n* `mkdocs serve` - Start the live-reloading docs server.\\n* `mkdocs build` - Build the documentation site.\\n* `mkdocs -h` - Print help message and exit.\\n\\n## Project layout\\n\\n    mkdocs.yml    # The configuration file.\\n    docs/\\n        index.md  # The documentation homepage.\\n        ...       # Other markdown pages, images and other files.\\n\\n---\\n\\n[hello_jit.void]({{voidc_repo_url}}/hello_jit.void)\\n\\n---\\n\\n{{ macros_info() }}\\n\\n\\n' _title_from_render NoneType None content NoneType None toc list [] meta dict hide = ['footer'] <p>To have all titles of all pages, use:</p> <pre><code>{% for page in navigation.pages %}\n- {{ page.title }}\n{% endfor %}\n</code></pre>"},{"location":"#plugin-filters","title":"Plugin Filters","text":"<p>These filters are provided as a standard by the macros plugin.</p> Variable Type Content pretty function (var_list, var, var_type, content, rows, header, e) <p>Default Mkdocs-Macro: Prettify a dictionary or object  (used for environment documentation, or debugging).</p> relative_url function (path) <p>Default Mkdocs-Macro: convert the path of any page according to MkDoc's internal logic, into a URL relative to the current page (implements the <code>normalize_url()</code> function from <code>mkdocs.util</code>). Typically used to manage custom navigation: <code>{{ page.url | relative_url }}</code>.</p>"},{"location":"#builtin-jinja2-filters","title":"Builtin Jinja2 Filters","text":"<p>These filters are provided by Jinja2 as a standard.</p> <p>See also the Jinja2 documentation on builtin filters.</p> Variable Type Content abs builtin_function_or_method <p>Return the absolute value of the argument.</p> attr function (environment, obj, name) <p>Get an attribute of an object. <code>foo|attr(\"bar\")</code> works like <code>foo.bar</code>, but returns undefined instead of falling back to <code>foo[\"bar\"]</code> if the attribute doesn't exist.</p> batch function (value, linecount, fill_with, tmp, item) <p>A filter that batches items. It works pretty much like <code>slice</code> just the other way round. It returns a list of lists with the given number of items. If you provide a second parameter this is used to fill up missing items. See this example.</p> capitalize function (s) <p>Capitalize a value. The first character will be uppercase, all others lowercase.</p> center function (value, width) <p>Centers the value in a field of a given width.</p> count builtin_function_or_method <p>Return the number of items in a container.</p> d function (value, default_value, boolean) <p>If the value is undefined it will return the passed default value, otherwise the value of the variable.</p> default function (value, default_value, boolean) <p>If the value is undefined it will return the passed default value, otherwise the value of the variable.</p> dictsort function (value, case_sensitive, by, reverse, sort_func) <p>Sort a dict and yield (key, value) pairs. Python dicts may not be in the order you want to display them in, so sort them first.</p> e function (s) <p>Replace the characters <code>&amp;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>'</code>, and <code>\"</code> in the string with HTML-safe sequences. Use this if you need to display text that might contain such characters in HTML.</p> escape function (s) <p>Replace the characters <code>&amp;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>'</code>, and <code>\"</code> in the string with HTML-safe sequences. Use this if you need to display text that might contain such characters in HTML.</p> filesizeformat function (value, binary, bytes, base, prefixes, i, prefix, unit) <p>Format the value like a 'human-readable' file size (i.e. 13 kB, 4.1 MB, 102 Bytes, etc).  Per default decimal prefixes are used (Mega, Giga, etc.), if the second parameter is set to <code>True</code> the binary prefixes are used (Mebi, Gibi).</p> first function (args, kwargs, b) <p>Return the first item of a sequence.</p> float function (value, default) <p>Convert the value into a floating point number. If the conversion doesn't work it will return <code>0.0</code>. You can override this default using the first parameter.</p> forceescape function (value) <p>Enforce HTML escaping.  This will probably double escape variables.</p> format function (value, args, kwargs) <p>Apply the given values to a <code>printf-style</code>_ format string, like <code>string % values</code>.</p> groupby function (args, kwargs, b) <p>Group a sequence of objects by an attribute using Python's :func:<code>itertools.groupby</code>. The attribute can use dot notation for nested access, like <code>\"address.city\"</code>. Unlike Python's <code>groupby</code>, the values are sorted first so only one group is returned for each unique value.</p> indent function (s, width, first, blank, newline, rv, lines) <p>Return a copy of the string with each line indented by 4 spaces. The first line and blank lines are not indented by default.</p> int function (value, default, base) <p>Convert the value into an integer. If the conversion doesn't work it will return <code>0</code>. You can override this default using the first parameter. You can also override the default base (10) in the second parameter, which handles input with prefixes such as 0b, 0o and 0x for bases 2, 8 and 16 respectively. The base is ignored for decimal numbers and non-string values.</p> join function (args, kwargs, b) <p>Return a string which is the concatenation of the strings in the sequence. The separator between elements is an empty string per default, you can define it with the optional parameter.</p> last function (environment, seq) <p>Return the last item of a sequence.</p> length builtin_function_or_method <p>Return the number of items in a container.</p> list function (args, kwargs, b) <p>Convert the value into a list.  If it was a string the returned list will be a list of characters.</p> lower function (s) <p>Convert a value to lowercase.</p> items function (value) <p>Return an iterator over the <code>(key, value)</code> items of a mapping.</p> map function (args, kwargs, b) <p>Applies a filter on a sequence of objects or looks up an attribute. This is useful when dealing with lists of objects but you are really only interested in a certain value of it.</p> min function (environment, value, case_sensitive, attribute) <p>Return the smallest item from the sequence.</p> max function (environment, value, case_sensitive, attribute) <p>Return the largest item from the sequence.</p> pprint function (value) <p>Pretty print a variable. Useful for debugging.</p> random function (context, seq) <p>Return a random item from the sequence.</p> reject function (args, kwargs, b) <p>Filters a sequence of objects by applying a test to each object, and rejecting the objects with the test succeeding.</p> rejectattr function (args, kwargs, b) <p>Filters a sequence of objects by applying a test to the specified attribute of each object, and rejecting the objects with the test succeeding.</p> replace function (eval_ctx, s, old, new, count) <p>Return a copy of the value with all occurrences of a substring replaced with a new one. The first argument is the substring that should be replaced, the second is the replacement string. If the optional third argument <code>count</code> is given, only the first <code>count</code> occurrences are replaced.</p> reverse function (value, rv, e) <p>Reverse the object or return an iterator that iterates over it the other way round.</p> round function (value, precision, method, func) <p>Round the number to a given precision. The first parameter specifies the precision (default is <code>0</code>), the second the rounding method.</p> safe function (value) <p>Mark the value as safe which means that in an environment with automatic escaping enabled this variable will not be escaped.</p> select function (args, kwargs, b) <p>Filters a sequence of objects by applying a test to each object, and only selecting the objects with the test succeeding.</p> selectattr function (args, kwargs, b) <p>Filters a sequence of objects by applying a test to the specified attribute of each object, and only selecting the objects with the test succeeding.</p> slice function (args, kwargs, b) <p>Slice an iterator and return a list of lists containing those items. Useful if you want to create a div containing three ul tags that represent columns.</p> sort function (environment, value, reverse, case_sensitive, attribute, key_func) <p>Sort an iterable using Python's :func:<code>sorted</code>.</p> string function (s) <p>Convert an object to a string if it isn't already. This preserves a :class:<code>Markup</code> string rather than converting it back to a basic string, so it will still be marked as safe and won't be escaped again.</p> striptags function (value) <p>Strip SGML/XML tags and replace adjacent whitespace by one space.</p> sum function (args, kwargs, b) <p>Returns the sum of a sequence of numbers plus the value of parameter 'start' (which defaults to 0).  When the sequence is empty it returns start.</p> title function (s, item) <p>Return a titlecased version of the value. I.e. words will start with uppercase letters, all remaining characters are lowercase.</p> trim function (value, chars) <p>Strip leading and trailing characters, by default whitespace.</p> truncate function (env, s, length, killwords, end, leeway, result) <p>Return a truncated copy of the string. The length is specified with the first parameter which defaults to <code>255</code>. If the second parameter is <code>true</code> the filter will cut the text at length. Otherwise it will discard the last word. If the text was in fact truncated it will append an ellipsis sign (<code>\"...\"</code>). If you want a different ellipsis sign than <code>\"...\"</code> you can specify it using the third parameter. Strings that only exceed the length by the tolerance margin given in the fourth parameter will not be truncated.</p> unique function (args, kwargs, b) <p>Returns a list of unique items from the given iterable.</p> upper function (s) <p>Convert a value to uppercase.</p> urlencode function (value, items) <p>Quote data for use in a URL path or query using UTF-8.</p> urlize function (eval_ctx, value, trim_url_limit, nofollow, target, rel, extra_schemes, policies, rel_parts, scheme, rv) <p>Convert URLs in text into clickable links.</p> wordcount function (s) <p>Count the words in that string.</p> wordwrap function (environment, s, width, break_long_words, wrapstring, break_on_hyphens, textwrap, line) <p>Wrap a string to the given width. Existing newlines are treated as paragraphs to be wrapped separately.</p> xmlattr function (eval_ctx, d, autospace, items, key, value, rv) <p>Create an SGML/XML attribute string based on the items in a dict.</p> tojson function (eval_ctx, value, indent, policies, dumps, kwargs) <p>Serialize an object to a string of JSON, and mark it safe to render in HTML. This filter is only for use in HTML documents.</p>"},{"location":"examples/","title":"Examples","text":"<p>...</p> hello.void<pre><code>{   v_import(\"level-00/voidc_target.void\");\n    v_import(\"level-00/voidc_types.void\");\n\n    v_import(\"llvm-c/Core.void\");\n    v_import(\"llvm-c/TargetMachine.void\");\n\n    v_import(\"printf.void\");\n}\n\n{   triple = LLVMGetDefaultTargetTriple();\n\n    tr_v = v_alloca(LLVMTargetRef);\n\n    LLVMGetTargetFromTriple(triple, tr_v, 0);\n\n    tr = v_load(tr_v);\n\n    cpu_name     = LLVMGetHostCPUName();\n    cpu_features = LLVMGetHostCPUFeatures();\n\n    target_machine =\n        LLVMCreateTargetMachine\n        (\n            tr,\n            triple,\n            cpu_name,\n            cpu_features,\n            LLVMCodeGenLevelDefault,\n            LLVMRelocPIC,                   //- WTF !?!\n            LLVMCodeModelDefault\n        );\n\n    LLVMDisposeMessage(cpu_features);\n    LLVMDisposeMessage(cpu_name);\n    LLVMDisposeMessage(triple);\n\n    //-----------------------------------------------------------------\n    llvm_ctx = v_target_get_voidc_llvm_ctx();\n    module = LLVMModuleCreateWithNameInContext(\"hello_mod\", llvm_ctx);\n\n    builder = v_target_get_voidc_builder();\n\n\n    int_ = v_type_get_llvm_type(int);\n\n    main_ft_ = LLVMFunctionType(int_, 0, 0, false);\n    main_f   = LLVMAddFunction(module, \"main\", main_ft_);\n\n    entry = LLVMAppendBasicBlockInContext(llvm_ctx, main_f, \"entry\");\n\n    LLVMPositionBuilderAtEnd(builder, entry);\n\n\n    typ_ = v_alloca(LLVMTypeRef);\n\n    char_     = v_type_get_llvm_type(char);\n    char_ptr_ = LLVMPointerType(char_, 0);\n\n    v_store(char_ptr_, typ_);\n\n    printf_ft_ = LLVMFunctionType(int_, typ_, 1, true);\n    printf_f   = LLVMAddFunction(module, \"printf\", printf_ft_);\n\n    str = LLVMBuildGlobalStringPtr(builder, \"Hello world!\\n\", \"str\");\n\n    val = v_alloca(LLVMValueRef);\n\n    v_store(str, val);\n\n    LLVMBuildCall2(builder, printf_ft_, printf_f, val, 1, \"\");\n\n\n    null_ = LLVMConstNull(int_);\n\n    LLVMBuildRet(builder, null_);\n\n\n    LLVMClearInsertionPosition(builder);\n\n    //-----------------------------------------------------------------\n    msg = LLVMPrintModuleToString(module);\n\n    printf(\"\\n%s\\n\", msg);\n\n    LLVMDisposeMessage(msg);\n\n    //-----------------------------------------------------------------\n    LLVMTargetMachineEmitToFile(target_machine,\n                                module,\n                                \"hello.o\",\n                                LLVMObjectFile,\n                                0);\n\n    //-----------------------------------------------------------------\n    LLVMDisposeModule(module);\n\n    LLVMDisposeTargetMachine(target_machine);\n}\n\n{   typ = v_alloca(v_type_ptr);\n\n    char_ptr = v_pointer_type(char, 0);\n\n    v_store(char_ptr, typ);\n\n    system_ft = v_function_type(int, typ, 1, false);\n\n    v_add_symbol(\"system\", system_ft, 0);\n}\n\n{   system(\"clang hello.o -o hello\");\n\n    system(\"bash -c ./hello\");\n}\n</code></pre> <p>...</p> <p>...</p> macros_test.void<pre><code>{   v_import(\"level-00\");\n    v_import(\"level-01\");\n    v_import(\"level-02\");\n\n    v_import(\"level-03/intrinsics_derive.void\");\n    v_import(\"level-03/local_objects.void\");\n    v_import(\"level-03/heap_objects.void\");\n    v_import(\"level-03/global_objects.void\");\n    v_import(\"level-03/coercions.void\");\n    v_import(\"level-03/namespaces.void\");\n    v_import(\"level-03/generics_etc.void\");\n    v_import(\"level-03/generating_ast.void\");\n    v_import(\"level-03/macros.void\");\n\n    v_import(\"printf.void\");\n}\n\n{   v_enable_level_01();\n    v_enable_level_02();\n\n    voidc_enable_intrinsics_derive();\n    voidc_enable_local_objects();\n    voidc_enable_heap_objects();\n    voidc_enable_global_objects();\n    voidc_enable_coercions();\n    voidc_enable_namespaces();\n    voidc_enable_generics_etc();\n    voidc_enable_generating_ast();\n    voidc_enable_macros();\n}\n\n//---------------------------------------------------------------------\n#define foo: (x, y) = x*y;\n\n{   v = foo(6, 7);\n\n    printf(\"v: %d\\n\", v);\n}\n\n#define bar: (v) = printf(\"bar: %d\\n\", v);\n\n{   bar(777);\n}\n\n\n//---------------------------------------------------------------------\n#define fact: (n) =\n(\n    #if (n &lt;= 0)    1\n    #else           n * fact(n-1)\n    #endif\n);\n\n{   n = 7;\n\n    printf(\"fact(%d): %d\\n\", n, fact(n));\n}\n\n\n//---------------------------------------------------------------------\n#define fib: (n)  =\n{\n    #define fibb: (a, b, m)  =\n    (\n        #if (m &gt; 0) fibb(b, a+b, m-1)\n        #else       a\n        #endif\n    );\n\n    fibb(0, 1, n)\n};\n\n{   n = 19;\n\n    printf(\"fib(%d): %d\\n\", n, fib(n));\n}\n\n\n//---------------------------------------------------------------------\n#define FOO: (x, y = 40+x)  =  x + y;\n\n{\n    printf(\"FOO(1, 1): %d\\n\", FOO(1, 1));\n\n    printf(\"FOO(1): %d\\n\", FOO(1));\n}\n\n\n//---------------------------------------------------------------------\n#define (_*_): (s: v_std_string_t, n) ~&gt; v_std_string_t  =\n{\n    tmp: &amp;v_std_string_t := {};\n\n    str = v_std_string_get(&amp;s);\n\n    for (i: &amp;int := 0; i &lt; n; ++i)\n    {\n        v_std_string_append(&amp;tmp, str);\n    }\n\n    tmp\n};\n\n#define (_.str): (s: *const char) ~&gt; v_std_string_t  =\n{\n    tmp: &amp;v_std_string_t := {};\n\n    v_std_string_set(&amp;tmp, s);\n\n    tmp\n};\n\n\n//{ voidc_verify_jit_module_optimized(true); }\n//{ v_debug_print_module(2); }\n{   ns = (\"Qwe\" : *const char).str * 7;\n\n    printf(\"ns: %s\\n\", v_std_string_get(&amp;ns));\n}\n\n\n#define (_*_): (a: char[4], n) ~&gt; v_std_string_t  =  (a: *const char).str * n;\n\n{   ns = \"Asd\" * 8;\n\n    printf(\"ns: %s\\n\", v_std_string_get(&amp;ns));\n}\n\n#define (_.c_str): (s: &amp;v_std_string_t) ~&gt;       *char  =  v_std_string_get(&amp;s);\n#define (_.c_str): (s:  v_std_string_t) ~&gt; *const char  =  v_std_string_get(&amp;s);\n\n{   ns = \"Zxc\" * 9;\n\n    printf(\"ns: %s\\n\", ns.c_str);\n}\n\n\n#define (_[]): (s: &amp;v_std_string_t, i) ~&gt; &amp;char  =  s.c_str[i];\n#define (_[]): (s:  v_std_string_t, i) ~&gt;  char  =  s.c_str[i];\n\n{   ns = \"Zxc\" * 10;\n\n    for (i: &amp;int := 0; i &lt; 10; ++i)   printf(\"ns[%d]: %c\\n\", i, ns[i]);\n}\n\n\n#define str: (s)  =  (s: *const char);\n\n{\n    printf(\"[%s]\\n\", (str(\"Qwerty\").str * 5).c_str);\n}\n\n\n//=====================================================================\n{   v_import(\"macros_mod_test.void\"); }\n\n\n//---------------------------------------------------------------------\n#do (my.instantiate_list(int),\n     my.instantiate_list(long))\n\n\n//---------------------------------------------------------------------\n{\n    l: &amp;my.list(int) := {};\n\n    l &lt;&lt; 5\n      &lt;&lt; 6\n      &lt;&lt; 7\n      &lt;&lt; 8\n      &lt;&lt; 9;\n\n    for (i: &amp;int := 0, n = l.size; i &lt; n; ++i)\n    {\n        printf(\"l[%d]: %d\\n\", i, l[i]);\n    }\n\n    l0: my.list(int) = {};\n\n    l1 = l0 &lt;&lt; 55;\n\n    l2 = l1 &lt;&lt; 66 &lt;&lt; 77;\n\n    l3 = l2 &lt;&lt; 88 &lt;&lt; 99;\n\n    ll: &amp;my.list(int)[4] := { l0, l1, l2, l3 };\n\n    for (i: &amp;int := 0; i &lt; 4; ++i)\n    {\n        for (j: &amp;int := 0, n = ll[i].size; j &lt; n; ++j)\n        {\n            printf(\"ll[%d][%d]: %d\\n\", i, j, ll[i][j]);\n        }\n    }\n\n\n    l.impl;     //- WTF !?!?!?!?!?!?!\n}\n\n\n//---------------------------------------------------------------------\n#define instantiate_list_plus: (T)\n{'unit_defn_list'\n\n    (_+_): (a: my.list(T), b: my.list(T)) ~&gt; my.list(T)  =\n    {\n        tmp: &amp;my.list(T) := a;\n\n        for (i: &amp;int := 0, n = b.size; i &lt; n; ++i)\n        {\n            tmp &lt;&lt; b[i];\n        }\n\n        tmp\n    };\n\n'unit_defn_list'}\n\n\n#do (instantiate_list_plus(long))\n\n\n//{ voidc_verify_jit_module_optimized(true); }\n//{ v_debug_print_module(2); }\n//---------------------------------------------------------------------\n{\n    a: my.list(long) = { 9, 8, 7, 6, 5 };\n    b: my.list(long) = { 4, 3 };\n\n    l = a + b +  { 2, 1, 0 };\n\n    for (i: &amp;int := 0, n = l.size; i &lt; n; ++i)\n    {\n        printf(\"l[%d]: %ld\\n\", i, l[i]);\n    }\n}\n</code></pre> macros_mod_test.void<pre><code>{   v_import(\"level-00\");\n    v_import(\"level-01\");\n    v_import(\"level-02\");\n\n    v_import(\"level-03/intrinsics_derive.void\");\n    v_import(\"level-03/local_objects.void\");\n    v_import(\"level-03/heap_objects.void\");\n    v_import(\"level-03/global_objects.void\");\n    v_import(\"level-03/coercions.void\");\n    v_import(\"level-03/namespaces.void\");\n    v_import(\"level-03/generics_etc.void\");\n    v_import(\"level-03/generating_ast.void\");\n    v_import(\"level-03/macros.void\");\n\n    v_import(\"printf.void\");\n}\n\n{   v_enable_level_01();\n    v_enable_level_02();\n\n    voidc_enable_intrinsics_derive();\n    voidc_enable_local_objects();\n    voidc_enable_heap_objects();\n    voidc_enable_global_objects();\n    voidc_enable_coercions();\n    voidc_enable_namespaces();\n    voidc_enable_generics_etc();\n    voidc_enable_generating_ast();\n    voidc_enable_macros();\n}\n\n//---------------------------------------------------------------------\n{   q_ref = v_reference_type(v_quark_t, 0);\n\n    q = v_quark_ptr_from_string;\n\n    v_add_symbol(\"list_q\", q_ref, q(\"my.list\"));\n\n    v_add_symbol(\"q_static_type_t\", q_ref, q(\"v_static_type_t\"));\n}\n\n\n//=====================================================================\n{   voidc_unit_begin_module(\"macros_mod_test_module\"); }\n\n\n//---------------------------------------------------------------------\nexport\nnamespace my {\n\n\n//---------------------------------------------------------------------\n#define list: (T: v_static_type_t) ~&gt; v_static_type_t  =  v_generic(\"my.list\", t(T));\n\n\n//---------------------------------------------------------------------\nprivate\nlist_op_braces_intrinsic: (aux: *void, vis: *voidc_visitor_t, self: *v_ast_base_t,\n                           arg_ptrs: **v_ast_expr_t, arg_count: unsigned\n                          ) ~&gt; void\n{\n//printf(\"list_op_braces_intrinsic: start\\n\");\n//defer printf(\"list_op_braces_intrinsic: stop\\n\");\n\n    tr: &amp;*v_type_t := v_get_result_type();\n\n    is_reference = v_type_is_reference(tr);\n\n    addr_sp: &amp;unsigned := undef;\n\n    if (is_reference)\n    {\n        addr_sp := v_type_refptr_get_address_space(tr);         //- Sic!\n        tr      := v_type_refptr_get_element_type(tr);          //- Sic!\n    }\n\n    vr: &amp;LLVMValueRef := v_get_result_value();\n\n    if (vr == 0)  vr := v_make_temporary(tr, 0);\n\n    list: &amp;v_ast_stmt_list_t :=\n    {'stmt_list'\n\n         my_any: &amp;v_std_any_t := {};\n\n         #define my_step: (lst, v)\n         {'stmt_list'\n\n             v_std_any_set_value(&amp;my_any, v);\n\n             v_list_append(lst, lst, &amp;my_any);\n\n         'stmt_list'}\n\n    'stmt_list'};\n\n    expr: &amp;v_ast_expr_t[2] := {};\n\n    v_ast_make_expr_compiled(expr+0, v_pointer_type(v_util_list_t, 0), vr);\n\n    typ = (aux: *v_type_t);\n\n    my_step_q = v_quark_from_string(\"my_step\");\n\n    stmt: &amp;v_ast_stmt_t := {};\n\n    for (i: &amp;int := 0; i &lt; arg_count; ++i)\n    {\n        v_reset_result();\n\n        v_set_result_type(typ);\n\n        v_ast_accept_visitor(arg_ptrs[i], vis);\n\n        val = v_get_result_value();\n\n        v_ast_make_expr_compiled(expr+1, typ, val);\n\n        v_ast_make_stmt_call(&amp;stmt, 0, my_step_q, expr, 2);\n\n        v_list_append(&amp;list, &amp;list, &amp;stmt);\n    }\n\n    v_ast_make_stmt_block(&amp;stmt, &amp;list, false);\n\n    v_reset_result();\n\n    v_ast_accept_visitor(&amp;stmt, vis);\n\n    if (is_reference) v_set_result_type(v_reference_type(tr, addr_sp));\n    else              v_set_result_type(tr);\n\n    v_set_result_value(vr);\n}\n\n//---------------------------------------------------------------------\nprivate\nregister_list_op_braces_intrinsic: (*void, vis: *voidc_visitor_t, self: *v_ast_base_t) ~&gt; void\n{\n    args = v_ast_expr_call_get_arg_list((self: *v_ast_expr_t));\n\n    arg0 = v_list_get_item(args, 0);        //- Element type\n    arg1 = v_list_get_item(args, 1);        //- List type\n\n    static_type_t = v_find_type_q(q_static_type_t);\n\n    v_reset_result();\n\n    v_set_result_type(static_type_t);\n\n    v_ast_accept_visitor(arg0, vis);\n\n    elt = (v_get_result_value() : *v_type_t);\n\n    v_reset_result();\n\n    v_set_result_type(static_type_t);\n\n    v_ast_accept_visitor(arg1, vis);\n\n    lst = (v_get_result_value() : *v_type_t);\n\n    sstr: &amp;v_std_string_t := {};\n\n    v_std_string_set(&amp;sstr, \"my.list_op_braces-\");\n\n    voidc_internal_std_string_append_type(&amp;sstr, elt);\n\n    iname = v_std_string_get(&amp;sstr);\n\n    v_add_overload(\"v.op_braces\", lst, iname);\n\n    v_add_intrinsic(iname, list_op_braces_intrinsic, elt);      //- Sic!\n}\n\n\n//---------------------------------------------------------------------\n#define instantiate_list: (T)\n{'unit_defn_list'\n\n  namespace my\n  {\n    #do (v_set_implementation_type(list(T), v_util_list_t))\n\n    private\n    namespace v_generic_ns(.my, c(list_detail, t(T)))       //- ???\n    {\n        impl_t = v_get_implementation_type(list(T));\n\n        alwaysinline\n        (_.impl): (s: &amp;list(T)) ~&gt; &amp;impl_t  =  *(&amp;s : *impl_t);\n    }\n\n    //-------------------------------------------------------------\n    inlinehint\n    (v_initialize(_)): (sp: *list(T), N: size_t) ~&gt; void\n    {\n        v_initialize(&amp;sp-&gt;impl, N);\n\n        for (i: &amp;int := 0; i &lt; N; ++i)\n        {\n            v_make_list_nil(&amp;sp[i].impl);\n        }\n    }\n\n    alwaysinline\n    (v_terminate(_)): (sp: *list(T), N: size_t) ~&gt; void\n    {\n        v_terminate(&amp;sp-&gt;impl, N);\n    }\n\n    alwaysinline\n    (v_copy(_)): (dst: *list(T), src: *const list(T), N: size_t) ~&gt; void\n    {\n        v_copy(&amp;dst-&gt;impl, &amp;src-&gt;impl, N);\n    }\n\n    #do (register_list_op_braces(T, list(T)))\n\n    //-------------------------------------------------------------\n    inlinehint\n    (_[]): (sp: list(T), i: size_t) ~&gt; T\n    {\n        a = v_list_get_item(&amp;sp.impl, i);\n        v_assert(a);\n\n        return  v_std_any_get_value(T, a);\n    }\n\n    inlinehint\n    (_&lt;&lt;_): (sp: list(T), v: T) ~&gt; list(T)\n    {\n        a: &amp;v_std_any_t := {};\n\n        v_std_any_set_value(&amp;a, v);\n\n        v_list_append(&amp;v_get_return_value().impl, &amp;sp.impl, &amp;a);\n    }\n\n    inlinehint\n    (_&lt;&lt;_): (sp: &amp;list(T), v: T) ~&gt; &amp;list(T)  =\n    {\n        a: &amp;v_std_any_t := {};\n\n        v_std_any_set_value(&amp;a, v);\n\n        lst = &amp;sp.impl;\n\n        v_list_append(lst, lst, &amp;a);\n\n        sp\n    };\n\n    alwaysinline\n    (_.size): (sp: list(T)) ~&gt; size_t  =  v_list_get_size(&amp;sp.impl);\n\n  }   //- namespace my\n\n'unit_defn_list'}\n\n\n//---------------------------------------------------------------------\nenable_list_effort: (*void) ~&gt; void\n{\n    v_add_intrinsic(\"register_list_op_braces\", register_list_op_braces_intrinsic, 0);\n}\n\n\n//---------------------------------------------------------------------\n}   //- namespace my\n\n\n//=====================================================================\n{   voidc_unit_end_module(); }\n\n\n//---------------------------------------------------------------------\n{   v_export_effort(my.enable_list_effort, 0); }\n</code></pre> <p>...</p> <p>...</p> geometry.void<pre><code>{ voidc_import(\"libvoidc.void\"); }\n{ voidc_make_header(\"geometry\"); }\n//---------------------------------------------------------------------\n{\n    v_export_import(\"cstdio.void\");\n    v_export_import(\"type_traits.void\");\n}\n\n\n//---------------------------------------------------------------------\ndouble = float(64);\n\nfabs: (double) ~&gt; double;\n\n\n//---------------------------------------------------------------------\n#define (_&lt;&lt;_): (f: *FILE, v) ~&gt; *FILE  =\n{\n    t = v_typeof(v);\n\n  #if (t.is_reference)\n\n    t = t.element_type;\n\n  #endif\n\n  #if ((t.is_array  ||  t.is_pointer)  &amp;&amp;  t.element_type == char)\n\n    fprintf(f, \"%s\", v);\n\n  #else\n\n    v.print_to_file(f);\n\n  #endif\n\n    f\n};\n\n\n//---------------------------------------------------------------------\nnamespace Geometry\n{\n\n\n//---------------------------------------------------------------------\nis_equal: (x: double, y: double) ~&gt; bool;\n\nalwaysinline\nis_finite: (x: double) ~&gt; bool  =  fabs(x) &lt; 1e15;      //- ?...\n\ninfinity = 1e1000;\n\ndet_3: (v: &amp;double[9]) ~&gt; double;\n\nseq_equal: (a: *const double, b: *const double, n: int) ~&gt; bool;\n\n\n//=====================================================================\n//- Vector (2D)\n//=====================================================================\nstruct Vector\n{\n    x: double;\n    y: double;\n};\n\n(_.print_to_file()): (v: Vector, f: *FILE) ~&gt; void;\n\n//---------------------------------------------------------------------\nalwaysinline\n(_+_): (a: Vector, b: Vector) ~&gt; Vector  =  {a.x+b.x, a.y+b.y};\n\nalwaysinline\n(_-_): (a: Vector, b: Vector) ~&gt; Vector  =  {a.x-b.x, a.y-b.y};\n\nalwaysinline\n(+_): (a: Vector) ~&gt; Vector  =  a;\n\nalwaysinline\n(-_): (a: Vector) ~&gt; Vector  =  {-a.x, -a.y};\n\nalwaysinline\n(_*_): (a: Vector, k: double) ~&gt; Vector  =  {a.x*k, a.y*k};\n\nalwaysinline\n(_*__): (k: double, a: Vector) ~&gt; Vector  =  {k*a.x, k*a.y};\n\nalwaysinline\n(_/_): (a: Vector, k: double) ~&gt; Vector  =  {a.x/k, a.y/k};\n\n(_==_): (a: Vector, b: Vector) ~&gt; bool;\n\nalwaysinline\n(_!=_): (a: Vector, b: Vector) ~&gt; bool  =  !(a == b);\n\n//---------------------------------------------------------------------\nnamespace Vector\n{\n    zero:     Vector = {0, 0};\n    unit_x:   Vector = {1, 0};\n    unit_y:   Vector = {0, 1};\n    infinity: Vector = {infinity, infinity};\n}\n\n//---------------------------------------------------------------------\nalwaysinline\n(_.dot()): (a: Vector, b: Vector) ~&gt; double  =  a.x*b.x + a.y*b.y;\n\nalwaysinline\n(_.crs()): (a: Vector, b: Vector) ~&gt; double  =  a.x*b.y - a.y*b.x;\n\nalwaysinline\n(_.is_finite()): (a: Vector) ~&gt; bool  =  is_finite(a.x)  &amp;&amp;  is_finite(a.y);\n\n\n//=====================================================================\n//- Projective point (2D)\n//=====================================================================\nstruct Point\n{\n    x: double;\n    y: double;\n    w: double;\n};\n\n//---------------------------------------------------------------------\n(_.print_to_file()): (p: Point, f: *FILE) ~&gt; void;\n\n//---------------------------------------------------------------------\nalwaysinline\n(_+_): (p: Point, v: Vector) ~&gt; Point  =  {p.x + p.w*v.x, p.y + p.w*v.y, p.w};\n\n#define (_-_): (a: Point, b)  =\n{\n    t = v_typeof(b);\n\n  #if (t.is_reference)  t = t.element_type;   #endif\n\n  #if (t == Point)\n\n    ret: Vector = {a.x/a.w - b.x/b.w, a.y/a.w - b.y/b.w};\n\n  #endif\n\n  #if (t == Vector)\n\n    ret: Point = {a.x - a.w*b.x, a.y - a.w*b.y, a.w};\n\n  #endif\n\n    ret\n};\n\n//---------------------------------------------------------------------\n(_.norm()): (p: &amp;Point) ~&gt; bool;\n\n(_.is_affine()): (p: &amp;Point) ~&gt; bool;\n\n(_==_): (a: &amp;Point, b: &amp;Point) ~&gt; bool;\n\nalwaysinline\n(_!=_): (a: &amp;Point, b: &amp;Point) ~&gt; bool  =  !(a == b);\n\n//---------------------------------------------------------------------\nnamespace Point\n{\n    zero:   Point = {0, 0, 1};\n    unit_x: Point = {1, 0, 1};\n    unit_y: Point = {0, 1, 1};\n    inf_x:  Point = {1, 0, 0};\n    inf_y:  Point = {0, 1, 0};\n}\n\n\n//=====================================================================\n//- Projective line (2D)\n//=====================================================================\nstruct Line\n{\n    cx: double;\n    cy: double;\n    cw: double;\n};\n\n//---------------------------------------------------------------------\n(_.print_to_file()): (l: Line, f: *FILE) ~&gt; void;\n\n//---------------------------------------------------------------------\nalwaysinline\n(_+_): (l: Line, v: Vector) ~&gt; Line  =  {l.cx, l.cy, l.cw - l.cx*v.x - l.cy*v.y};\n\nalwaysinline\n(_-_): (l: Line, v: Vector) ~&gt; Line  =  {l.cx, l.cy, l.cw + l.cx*v.x + l.cy*v.y};\n\n//---------------------------------------------------------------------\n(_.norm()): (l: &amp;Line) ~&gt; bool;\n\n(_.is_affine()): (l: &amp;Line) ~&gt; bool;\n\n(_==_): (a: &amp;Line, b: &amp;Line) ~&gt; bool;\n\nalwaysinline\n(_!=_): (a: &amp;Line, b: &amp;Line) ~&gt; bool  =  !(a == b);\n\n//---------------------------------------------------------------------\nnamespace Line\n{\n    infinity: Line = {0, 0, 1};\n    abscissa: Line = {0, 1, 0};\n    ordinate: Line = {1, 0, 0};\n}\n\n\n//=====================================================================\n(_.incident()): (l: &amp;Line, p: &amp;Point) ~&gt; bool;\n\n//---------------------------------------------------------------------\nalwaysinline\n(_&amp;_): (a: Point, b: Point) ~&gt; Line  =  {a.y*b.w - a.w*b.y, a.w*b.x - a.x*b.w, a.x*b.y - a.y*b.x};\n\nalwaysinline\n(_&amp;_): (a: Line, b: Line) ~&gt; Point  =  {a.cy*b.cw - a.cw*b.cy, a.cw*b.cx - a.cx*b.cw, a.cx*b.cy - a.cy*b.cx};\n\n\n//=====================================================================\n//- Projective transformation (2D)\n//=====================================================================\nstruct Transform\n{\n    double[9];\n};\n\n//---------------------------------------------------------------------\n(_.print_to_file()): (t: &amp;Transform, f: *FILE) ~&gt; void;\n\n//---------------------------------------------------------------------\n(_.norm()): (t: &amp;Transform) ~&gt; bool;\n\n(_.is_regular()): (t: &amp;Transform) ~&gt; bool;\n\n(_.is_affine()): (t: &amp;Transform) ~&gt; bool;\n\n(_==_): (a: &amp;Transform, b: &amp;Transform) ~&gt; bool;\n\nalwaysinline\n(_!=_): (a: &amp;Transform, b: &amp;Transform) ~&gt; bool  =  !(a == b);\n\n//---------------------------------------------------------------------\nalwaysinline\n(_.det()): (t: &amp;Transform) ~&gt; double  =  det_3(t[0]);\n\n\n//---------------------------------------------------------------------\n#define (_()): (t: Transform, v)  =  v.transform_by(t);\n\n//---------------------------------------------------------------------\n(_.transform_by()): (v: Vector, t: Transform) ~&gt; Vector;\n(_.transform_by()): (p: Point, t: Transform) ~&gt; Point;\n(_.transform_by()): (l: Line, t: Transform) ~&gt; Line;\n\n//---------------------------------------------------------------------\n(_+_): (t: Transform, v: Vector) ~&gt; Transform;\n\nalwaysinline\n(_-_): (t: Transform, v: Vector) ~&gt; Transform  =  t + -v;\n\n(_*_): (a: Transform, b: Transform) ~&gt; Transform;\n(_*__): (k: double, t: Transform) ~&gt; Transform;\n\n(~_): (t: Transform) ~&gt; Transform;\n\n(_/_): (a: Transform, b: Transform) ~&gt; Transform;\n\n//---------------------------------------------------------------------\nalwaysinline\n(_.scaled()): (t: Transform, k: double) ~&gt; Transform  =  k * t;\n\nalwaysinline\n(_.shifted()): (t: Transform, v: Vector) ~&gt; Transform  =  t + v;\n\n(_.rotated()): (t: Transform, d: double) ~&gt; Transform;\n\n//---------------------------------------------------------------------\nnamespace Transform\n{\n    map4: (i1: &amp;Point, i2: &amp;Point, i3: &amp;Point, i4: &amp;Point,\n           o1: &amp;Point, o2: &amp;Point, o3: &amp;Point, o4: &amp;Point\n          ) ~&gt; Transform;\n\n    map3: (i1: &amp;Point, i2: &amp;Point, i3: &amp;Point,\n           o1: &amp;Point, o2: &amp;Point, o3: &amp;Point\n          ) ~&gt; Transform;\n\n    map2: (i1: &amp;Point, i2: &amp;Point,\n           o1: &amp;Point, o2: &amp;Point\n          ) ~&gt; Transform;\n\n    map2_mirror: (i1: &amp;Point, i2: &amp;Point,\n                  o1: &amp;Point, o2: &amp;Point\n                 ) ~&gt; Transform;\n\n    //------------------------------------------------------\n    identity: Transform = {{ 1, 0, 0,  0, 1, 0,  0, 0, 1 }};\n    flip_x:   Transform = {{-1, 0, 0,  0, 1, 0,  0, 0, 1 }};\n    flip_y:   Transform = {{ 1, 0, 0,  0,-1, 0,  0, 0, 1 }};\n}\n\n//---------------------------------------------------------------------\n}   //- namespace Geometry\n</code></pre> geometry_mod.void<pre><code>{ v_import(\"libvoidc.void\"); }\n{ voidc_make_module(\"geometry\"); }\n//---------------------------------------------------------------------\n{\n    v_import(\"geometry.void\");\n}\n\n\n//---------------------------------------------------------------------\nsin: (double) ~&gt; double;\ncos: (double) ~&gt; double;\n\nM_PI = 3.14159265358979323846264338327950288419716939937510582;\n\n\n//---------------------------------------------------------------------\nnamespace Geometry\n{\n\n\n//---------------------------------------------------------------------\nEPSILON = 1e-9;\n\nis_equal: (x: double, y: double) ~&gt; bool\n{\n    if (x == y)  return true;\n\n    size = fabs(x) + fabs(y);\n\n    if (size &lt;= EPSILON)  return true;\n\n    diff = fabs(x - y);\n\n    if (diff &lt;= EPSILON)  return true;\n\n    if (size &gt; 1  &amp;&amp;  diff/size &lt;= EPSILON)  return true;\n\n    return  false;\n}\n\ndet_3: (v: &amp;double[9]) ~&gt; double\n{\n    v00 = v[0]; v01 = v[1]; v02 = v[2];\n    v10 = v[3]; v11 = v[4]; v12 = v[5];\n    v20 = v[6]; v21 = v[7]; v22 = v[8];\n\n    return  v00 * (v11*v22 - v12*v21)\n          - v10 * (v01*v22 - v02*v21)\n          + v20 * (v01*v12 - v02*v11);\n}\n\n\n//---------------------------------------------------------------------\nseq_equal: (a: *const double, b: *const double, n: int) ~&gt; bool\n{\n    ret: &amp;bool := true;\n\n    for (i: &amp;int := 0; i &lt; n; ++i)  if (!is_equal( a[i], b[i]))  { ret := false;  break; }\n\n    if (ret)  return true;\n\n    for (i: &amp;int := 0; i &lt; n; ++i)  if (!is_equal(-a[i], b[i]))  { return false; }\n\n    return  true;\n}\n\n\n//=====================================================================\n//- Vector (2D)\n//=====================================================================\n(_.print_to_file()): (v: Vector, f: *FILE) ~&gt; void\n{\n    fprintf(f, \"(%g, %g)\", v.x, v.y);\n}\n\n(_==_): (a: Vector, b: Vector) ~&gt; bool\n{\n    return  is_equal(a.x, b.x)  &amp;&amp;  is_equal(a.y, b.y);\n}\n\n\n//=====================================================================\n//- Projective point (2D)\n//=====================================================================\n(_.print_to_file()): (p: Point, f: *FILE) ~&gt; void\n{\n    fprintf(f, \"(%g, %g, %g)\", p.x, p.y, p.w);\n}\n\n//---------------------------------------------------------------------\n(_.norm()): (p: &amp;Point) ~&gt; bool\n{\n    pa: &amp;double[3] := {p.x, p.y, p.w};\n\n    d: &amp;double := 0;\n\n    for (i: &amp;int := 0; i &lt; 3; ++i)\n    {\n        if (!is_finite(pa[i]))  return false;\n\n        if (di = fabs(pa[i]), d &lt; di)   d := di;\n    }\n\n    if (d == 0)  return false;\n    if (d == 1)  return true;\n\n    p.x /= d;\n    p.y /= d;\n    p.w /= d;\n\n    return  true;\n}\n\n//---------------------------------------------------------------------\n(_.is_affine()): (p: &amp;Point) ~&gt; bool\n{\n    if (!p.norm())  return false;\n\n    return  fabs(p.w) &gt; EPSILON;\n}\n\n//---------------------------------------------------------------------\n(_==_): (a: &amp;Point, b: &amp;Point) ~&gt; bool\n{\n    if (!(a.norm()  &amp;&amp;  b.norm()))  return false;\n\n    sa: &amp;double[] := {a.x, a.y, a.w};\n    sb: &amp;double[] := {b.x, b.y, b.w};\n\n    return  seq_equal(sa, sb, 3);\n}\n\n\n//=====================================================================\n//- Projective line (2D)\n//=====================================================================\n(_.print_to_file()): (l: Line, f: *FILE) ~&gt; void\n{\n    fprintf(f, \"(%g, %g, %g)\", l.cx, l.cy, l.cw);\n}\n\n//---------------------------------------------------------------------\n(_.norm()): (l: &amp;Line) ~&gt; bool\n{\n    la: &amp;double[3] := {l.cx, l.cy, l.cw};\n\n    d: &amp;double := 0;\n\n    for (i: &amp;int := 0; i &lt; 3; ++i)\n    {\n        if (!is_finite(la[i]))  return false;\n\n        if (di = fabs(la[i]), d &lt; di)   d := di;\n    }\n\n    if (d == 0)  return false;\n    if (d == 1)  return true;\n\n    l.cx /= d;\n    l.cy /= d;\n    l.cw /= d;\n\n    return  true;\n}\n\n//---------------------------------------------------------------------\n(_.is_affine()): (l: &amp;Line) ~&gt; bool\n{\n    if (!l.norm())  return false;\n\n    return  fabs(l.cx) &gt; EPSILON  ||  fabs(l.cy) &gt; EPSILON;\n}\n\n//---------------------------------------------------------------------\n(_==_): (a: &amp;Line, b: &amp;Line) ~&gt; bool\n{\n    if (!(a.norm()  &amp;&amp;  b.norm()))  return false;\n\n    sa: &amp;double[] := {a.cx, a.cy, a.cw};\n    sb: &amp;double[] := {b.cx, b.cy, b.cw};\n\n    return  seq_equal(sa, sb, 3);\n}\n\n\n//=====================================================================\n(_.incident()): (l: &amp;Line, p: &amp;Point) ~&gt; bool\n{\n    l.norm();\n    p.norm();\n\n    return  fabs(l.cx*p.x + l.cy*p.y + l.cw*p.w) &lt; EPSILON;\n}\n\n\n//=====================================================================\n//- Projective transformation (2D)\n//=====================================================================\n(_.print_to_file()): (t: &amp;Transform, f: *FILE) ~&gt; void\n{\n    t = t[0];\n\n    fprintf(f, \"(%g, %g, %g, %g, %g, %g, %g, %g, %g)\", t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]);\n}\n\n//---------------------------------------------------------------------\n(_.norm()): (t: &amp;Transform) ~&gt; bool\n{\n    t = t[0];\n\n    d: &amp;double := 0;\n\n    for (i: &amp;int := 0; i &lt; 9; ++i)\n    {\n        if (!is_finite(t[i]))  return false;\n\n        if (di = fabs(t[i]), d &lt; di)  d := di;\n    }\n\n    if (d == 0)  return false;\n    if (d == 1)  return true;\n\n    for (i: &amp;int := 0; i &lt; 9; ++i)\n    {\n        t[i] /= d;\n    }\n\n    return  true;\n}\n\n//---------------------------------------------------------------------\n(_.is_regular()): (t: &amp;Transform) ~&gt; bool\n{\n    if (!t.norm())  return false;\n\n    return  fabs(t.det()) &gt; EPSILON;\n}\n\n//---------------------------------------------------------------------\n(_.is_affine()): (t: &amp;Transform) ~&gt; bool\n{\n    if (!t.norm())  return false;\n\n    t = t[0];\n\n    return  fabs(t[6]) &lt;= EPSILON  &amp;&amp;\n            fabs(t[7]) &lt;= EPSILON  &amp;&amp;\n            fabs(t[8]) &gt;  EPSILON;\n}\n\n//---------------------------------------------------------------------\n(_==_): (a: &amp;Transform, b: &amp;Transform) ~&gt; bool\n{\n    if (!(a.norm()  &amp;&amp;  b.norm()))  return false;\n\n    return  seq_equal(a[0], b[0], 9);\n}\n\n//---------------------------------------------------------------------\n(_.transform_by()): (v: Vector, t: Transform) ~&gt; Vector\n{\n    t = t[0];\n\n    x = t[0]*v.x + t[1]*v.y + t[2];\n    y = t[3]*v.x + t[4]*v.y + t[5];\n    w = t[6]*v.x + t[7]*v.y + t[8];\n\n    return  { x/w, y/w };\n}\n\n(_.transform_by()): (p: Point, t: Transform) ~&gt; Point\n{\n    t = t[0];\n\n    x = t[0]*p.x + t[1]*p.y + t[2]*p.w;\n    y = t[3]*p.x + t[4]*p.y + t[5]*p.w;\n    w = t[6]*p.x + t[7]*p.y + t[8]*p.w;\n\n    return  { x, y, w };\n}\n\n(_.transform_by()): (l: Line, t: Transform) ~&gt; Line\n{\n    t = t[0];\n\n    cx = det_3({ l.cx, t[3], t[6],\n                 l.cy, t[4], t[7],\n                 l.cw, t[5], t[8] });\n\n    cy = det_3({ t[0], l.cx, t[6],\n                 t[1], l.cy, t[7],\n                 t[2], l.cw, t[8] });\n\n    cw = det_3({ t[0], t[3], l.cx,\n                 t[1], t[4], l.cy,\n                 t[2], t[5], l.cw });\n\n    return  { cx, cy, cw };\n}\n\n//---------------------------------------------------------------------\n(_+_): (t: Transform, v: Vector) ~&gt; Transform\n{\n    t = t[0];\n\n    xx = t[0] + v.x*t[6];\n    xy = t[1] + v.x*t[7];\n    xw = t[2] + v.x*t[8];\n\n    yx = t[3] + v.y*t[6];\n    yy = t[4] + v.y*t[7];\n    yw = t[5] + v.y*t[8];\n\n    wx = t[6];\n    wy = t[7];\n    ww = t[8];\n\n    return  {{ xx, xy, xw,\n               yx, yy, yw,\n               wx, wy, ww }};\n}\n\n//---------------------------------------------------------------------\n(_*_): (a: Transform, b: Transform) ~&gt; Transform\n{\n    a = a[0];\n    b = b[0];\n\n    xx = a[0]*b[0] + a[1]*b[3] + a[2]*b[6];\n    xy = a[0]*b[1] + a[1]*b[4] + a[2]*b[7];\n    xw = a[0]*b[2] + a[1]*b[5] + a[2]*b[8];\n\n    yx = a[3]*b[0] + a[4]*b[3] + a[5]*b[6];\n    yy = a[3]*b[1] + a[4]*b[4] + a[5]*b[7];\n    yw = a[3]*b[2] + a[4]*b[5] + a[5]*b[8];\n\n    wx = a[6]*b[0] + a[7]*b[3] + a[8]*b[6];\n    wy = a[6]*b[1] + a[7]*b[4] + a[8]*b[7];\n    ww = a[6]*b[2] + a[7]*b[5] + a[8]*b[8];\n\n    return  {{ xx, xy, xw,\n               yx, yy, yw,\n               wx, wy, ww }};\n}\n\n(_*__): (k: double, t: Transform) ~&gt; Transform\n{\n    t = t[0];\n\n    xx = k*t[0];\n    xy = k*t[1];\n    xw = k*t[2];\n\n    yx = k*t[3];\n    yy = k*t[4];\n    yw = k*t[5];\n\n    wx =   t[6];\n    wy =   t[7];\n    ww =   t[8];\n\n    return  {{ xx, xy, xw,\n               yx, yy, yw,\n               wx, wy, ww }};\n}\n\n//---------------------------------------------------------------------\n(~_): (t: Transform) ~&gt; Transform\n{\n    t = t[0];\n\n    xx = t[4]*t[8] - t[5]*t[7];\n    xy = t[2]*t[7] - t[1]*t[8];\n    xw = t[1]*t[5] - t[2]*t[4];\n\n    yx = t[5]*t[6] - t[3]*t[8];\n    yy = t[0]*t[8] - t[2]*t[6];\n    yw = t[2]*t[3] - t[0]*t[5];\n\n    wx = t[3]*t[7] - t[4]*t[6];\n    wy = t[1]*t[6] - t[0]*t[7];\n    ww = t[0]*t[4] - t[1]*t[3];\n\n    r: &amp;Transform := {{ xx,xy,xw, yx,yy,yw, wx,wy,ww }};\n\n    if (r.det() &lt; 0)\n    {\n        r = r[0];\n\n        for (i: &amp;int := 0; i &lt; 9; ++i)  r[i] := -r[i];\n    }\n\n    return  r;\n}\n\n//---------------------------------------------------------------------\n(_/_): (a: Transform, b: Transform) ~&gt; Transform\n{\n    return  a * (~b);\n}\n\n//---------------------------------------------------------------------\n(_.rotated()): (t: Transform, d: double) ~&gt; Transform\n{\n    a = d * (M_PI/180);\n\n    sa = sin(a);\n    ca = cos(a);\n\n    r: Transform = {{  ca, -sa,  0,\n                       sa,  ca,  0,\n                        0,   0,  1  }};\n\n    return  r * t;\n}\n\n//---------------------------------------------------------------------\nprivate\nmap4_util: (o1: &amp;Point, o2: &amp;Point, o3: &amp;Point, o4: &amp;Point) ~&gt; Transform\n{\n    o1.norm();\n    o2.norm();\n    o3.norm();\n    o4.norm();\n\n    a1 = det_3({ o4.x, o2.x, o3.x,\n                 o4.y, o2.y, o3.y,\n                 o4.w, o2.w, o3.w });\n\n    a2 = det_3({ o1.x, o4.x, o3.x,\n                 o1.y, o4.y, o3.y,\n                 o1.w, o4.w, o3.w });\n\n    a3 = det_3({ o1.x, o2.x, o4.x,\n                 o1.y, o2.y, o4.y,\n                 o1.w, o2.w, o4.w });\n\n    return  {{ o1.x*a1, o2.x*a2, o3.x*a3,\n               o1.y*a1, o2.y*a2, o3.y*a3,\n               o1.w*a1, o2.w*a2, o3.w*a3 }};\n}\n\n//---------------------------------------------------------------------\nTransform.map4: (i1: &amp;Point, i2: &amp;Point, i3: &amp;Point, i4: &amp;Point,\n                 o1: &amp;Point, o2: &amp;Point, o3: &amp;Point, o4: &amp;Point\n                ) ~&gt; Transform\n{\n    t1 = map4_util(i1, i2, i3, i4);\n    t2 = map4_util(o1, o2, o3, o4);\n\n    return  t2 / t1;\n}\n\nTransform.map3: (i1: &amp;Point, i2: &amp;Point, i3: &amp;Point,\n                 o1: &amp;Point, o2: &amp;Point, o3: &amp;Point\n                ) ~&gt; Transform\n{\n    i4 = i3 + (i2 - i1);\n    o4 = o3 + (o2 - o1);\n\n    return  Transform.map4(i1, i2, i3, i4,  o1, o2, o3, o4);\n}\n\nTransform.map2: (i1: &amp;Point, i2: &amp;Point,\n                 o1: &amp;Point, o2: &amp;Point\n                ) ~&gt; Transform\n{\n    v = i2 - i1;    v: Vector = { -v.y, v.x };\n\n    i3 = i1 + v;\n\n    v = o2 - o1;    v: Vector = { -v.y, v.x };\n\n    o3 = o1 + v;\n\n    return  Transform.map3(i1, i2, i3,  o1, o2, o3);\n}\n\nTransform.map2_mirror: (i1: &amp;Point, i2: &amp;Point,\n                        o1: &amp;Point, o2: &amp;Point\n                       ) ~&gt; Transform\n{\n    v = i2 - i1;    v: Vector = { -v.y, v.x };\n\n    i3 = i1 + v;\n\n    v = o2 - o1;    v: Vector = { v.y, -v.x };\n\n    o3 = o1 + v;\n\n    return  Transform.map3(i1, i2, i3,  o1, o2, o3);\n}\n\n//---------------------------------------------------------------------\n}   //- namespace Geometry\n\n\n//---------------------------------------------------------------------\n{ voidc_emit_module(\"geometry_mod.o\"); }\n//---------------------------------------------------------------------\n</code></pre> <p>...</p>"},{"location":"strange/","title":"Strange","text":""},{"location":"strange/#the-void-programming-language","title":"The Void Programming Language","text":"<p><p>\"Programming language is not a templum, it's a workshop.\" (c)...</p></p> <p>Void is an open-source, highly extensible programming language, minimalistic and low-level in its base. It uses LLVM for code generation and can be seen as a thin (well, in some sense) shell around it. Extensibility of Void is practically limitless (any syntax/semantics), restricted only by decidability and your money imagination.</p> <p>Here is the author's blog dedicated to this project: Void Blog.</p>"},{"location":"strange/#hello-world","title":"Hello world:","text":"<pre><code>{ v_import(\"printf.void\"); }        // Import declaration of C's \"printf\"\n\n{ printf(\"Hello, world\\n\"); }       // Just call it...\n</code></pre> <p>See more details in tutorial. (Spoiler: it's all about those magic curly braces... )</p>"},{"location":"strange/#main-architecture-features","title":"Main architecture features:","text":"<ul> <li> <p>Starting from minimalistic language \"kernel\", which is:</p> <ul> <li>Compatible with \"C\" by key types and calling conventions;</li> <li>Able to call (almost) arbitrary C-functions (from libc, LLVM, whatever);</li> <li>Has some built-in \"module importing\" system (with pre-compilation support);</li> <li>Has some predefined tools for further \"bootstrapping\".</li> </ul> </li> <li> <p>Continuing with exposing compiler's internal API(s):</p> <ul> <li>Extensible parser based on PEG-machinery;</li> <li>Extensible AST;</li> <li>Extensible compiler based on \"visitor pattern\";</li> <li>Exposing essential parts of LLVM-C API (Core, TargetMachine, etc.).</li> </ul> </li> <li> <p>Developing \"basic\" language features:</p> <ul> <li>Ability to create (C-compatible) functions;</li> <li>Basic set of control flow constructions: \"if then else\", \"block\", \"loop\", \"switch\", \"defer\";</li> <li>Comfortable \"syntactic sugar\" for grammar development;</li> <li>C-like expressions (with some additional \"twists\");</li> <li>Finally, some \"normal\" syntax for function's and variable's definitions/declarations.</li> </ul> </li> <li> <p>Extending the language:</p> <ul> <li>Comprehensive numeric literals;</li> <li>Sophisticated control flow constuctions: \"while\", \"for\", extended \"if then else\" and \"switch\";</li> <li>Conditional compilation;</li> <li>Aggregate \"initializations\";</li> <li>Simple compiler's handlers;</li> <li>\"Simple\" overloading of operators;</li> <li>\"Projections\" (functions with syntax <code>a.something</code>);</li> <li>Simple structures with named fields;</li> <li>\"Mangling\" (fancy function names to help overloading/projections);</li> <li>Function inlining;</li> <li>Unions (like in C).</li> </ul> </li> <li> <p>Advanced language features:</p> <ul> <li>Objects (\"simplified\" OOP);</li> <li>Coercions (\"single\", \"projective\" and \"injective\");</li> <li>Namespaces (regular and parameterized);</li> <li>Some support for generic types;</li> <li>Something like \"AST literals\";</li> <li>Macros (which are also templates);</li> <li>...</li> </ul> </li> <li> <p>...</p> </li> </ul> <p>For the moment (Sep 2024), language seems to be ready just for some early experiments...</p>"},{"location":"strange/#yet-another-example","title":"Yet another example:","text":"<pre><code>{ v_import(\"mainline.void\"); }      // Import \"mainline\" language\n{ v_enable_mainline(); }            // \"Enable\" it\n\n//---------------------------------------------------------------------\n// Constants\n\nA = 154476802108746166441951315019919837485664325669565431700026634898253202035277999;\nB =  36875131794129999827197811565225474825492979968971970996283137471637224634055579;\nC =   4373612677928697257861252602371390152816537558161613618621437993378423467772036;\n\n//---------------------------------------------------------------------\n{   num_t = uint(800);          // Kinda, typedef: 800 bits, unsigned\n\n    #define check_fruits: (a: num_t, b: num_t, c: num_t)  =     // Macro\n    {\n        ab = a + b;     ac = a + c;     bc = b + c;\n\n        a*ab*ac + b*ab*bc + c*ac*bc == 4*ab*ac*bc\n    };\n\n    printf: (*const char, ...) ~&gt; int;                  // Declaration\n\n    #if (check_fruits(A, B, C)) printf(\"\\nOK\\n\");       // Conditional\n    #else                       printf(\"\\nFail\\n\");     // compilation\n    #endif                                              // ...\n}\n</code></pre> <p>Note: Void is not intended to be seen as a complete/finished/whatever programming language in usual sense... In fact, it is merely a toolkit/workshop/boilerplate/etc. for development of programming languages per se, and for development of itself particularly.</p>"},{"location":"strange/#one-more-example","title":"One more example:","text":"<pre><code>{ v_import(\"mainline.void\"); }\n{ v_enable_mainline(); }\n\n//---------------------------------------------------------------------\ndouble = float(64);                 // Kinda, \"typedef\"\n\nsqrt: (double) ~&gt; double;\nceil: (double) ~&gt; double;\nlog:  (double) ~&gt; double;\n\n//---------------------------------------------------------------------\nN = 10001;                                      // For N-th prime ...\n\nS = (N*(log(N) + log(log(N))) : int) + 1;       // ... should be enough\n\nsieve = new bool[S];    defer delete[] sieve;\n\n//---------------------------------------------------------------------\n{   memset: (s: *void, c: int, n: size_t) ~&gt; *void;\n\n    memset(sieve, 0, S);\n\n    sieve[2] := true;\n\n    for (i: &amp;int := 3; i &lt; S; i += 2)\n    {\n        sieve[i] := true;\n    }\n\n    R = (ceil(sqrt(S)) : int);\n\n    for (i: &amp;int := 3; i &lt; R; i += 2)\n    {\n        if (sieve[i])\n        {\n            for (k: &amp;int := i*i, i2 = 2*i; k &lt; S; k += i2)\n            {\n                sieve[k] := false;\n            }\n        }\n    }\n}\n\n//---------------------------------------------------------------------\n{   n: &amp;int := 1;\n    p: &amp;int := 3;\n\n    for (; p &lt; S; p += 2)\n    {\n        if (sieve[p])\n        {\n            ++n;\n\n            if (n == N) break;\n        }\n    }\n\n    printf: (*const char, ...) ~&gt; int;\n\n    if (n == N) printf(\"Found: %d\\n\", p);\n    else        printf(\"Not found\\n\");\n}\n</code></pre>"},{"location":"strange/#nearest-todos","title":"Nearest TODO(s):","text":"<ul> <li> <p>Documenting everything written so far;</p> </li> <li> <p>Preparing for next developments:</p> <ul> <li>Standard library (strings, smart pointers, containers, etc.);</li> <li>Protocols:</li> <li>\"Variants and matching\",</li> <li>...</li> <li>\"Bootstrapping\"...</li> </ul> </li> <li> <p>...</p> </li> </ul>"},{"location":"strange/#installation","title":"Installation","text":"<p>The <code>voidc</code> is \"tested\" (well, in some sense) under Linux and Windows (MSYS2/Mingw64) environments.</p>"},{"location":"strange/#dependencies","title":"Dependencies:","text":"<ul> <li>LLVM/Clang (v.15 or later);</li> <li>C++ library immer (should be \"visible\" for include...).</li> </ul>"},{"location":"strange/#build","title":"Build:","text":"<p>Try scripts (CMake needed)...</p> <pre><code>$ ./mk_config\n\n$ ./mk_build\n</code></pre>"},{"location":"strange/#usage","title":"Usage","text":"<p>Currently (Sep 2024) <code>voidc</code> works mainly from it's source directory.</p> <p>You can try some of:</p> <pre><code>$ build/voidc hello.void\n\n$ build/voidc hello_jit.void\n</code></pre> <p>You should see the sacramental \"Hello, world!\" messages with some LLVM's printouts...</p> <p>BTW, first time it can take a while due to long (idk, 10-30 sec) compilation of huge <code>llvm-c/Core.void</code>.</p> <p>After that, try:</p> <pre><code>$ build/voidc level-03/macros_test.void\n</code></pre> <p>This \"script\" (with imports) uses almost all language features developed so far. And yes, first-time compilation of it can take even longer...</p>"},{"location":"strange/#contributing","title":"Contributing","text":"<p>Of course, contributions are welcome! But I must warn you that at this point I am a newbie to things like GitHub, project/community maintaining, etc.</p> <p>So, for any friendly help (on these topics especially) I'll be greatly appreciated!</p>"},{"location":"strange/#license","title":"License","text":"<p>LGPL-3.0</p>"},{"location":"tutorial/","title":"The Void Programming Language Tutorial","text":"<p>Disclaimer: this tutorial assumes the reader has a rather good knowledge of C/C++, understands basic notions of LLVM-C API, and in general \"has an idea of how compilers work\"...</p>"},{"location":"tutorial/#01-the-hello-world-example","title":"0.1. The \"Hello, world\" example:","text":"<pre><code>{ v_import(\"printf.void\"); }        // Import declaration of C's \"printf\"\n\n{ printf(\"Hello, world\\n\"); }       // Just call it...\n</code></pre> <p>Void's source text is a sequence of so-called \"units\". In example above you can see two of them: the first with <code>v_import</code>, and the second with <code>printf</code>. Each unit is (usually) enclosed in (magic) curly braces and can be thought of as a function body in a \"C\"-like syntax.</p> <p>Units are processed by the <code>voidc</code> compiler sequentially, one by one. For each unit, the following operations are performed, in order:</p> <ol> <li>Source text is parsed down to the enclosing <code>}</code>, resulting in the AST.</li> <li>The AST is compiled to the object file (in memory) which contains the \"unit action\" function.</li> <li>This \"unit action\" is executed in compiler's environment by LLVM's JIT.</li> </ol> <p>I.e. parsing of the next unit will start right after the previous one has been executed...</p> <p>In the \"Hello, world\" example above the first unit calls the compiler's intrinsic function <code>v_import</code>. This function receives the name of the source file \"printf.void\" (from the Voidc's root directory) and \"imports\" it into the \"current scope\". The \"printf.void\" file \"gives out\" only the declaration of C's <code>printf</code> function. But that's enough for the second unit which calls this function with sacramental greeting message as an argument.</p> <p>Essential Note: it is very important to understand the consequences of this parse-compile-execute architecture of the Voidc's \"mainloop\"... It's the key to enormous extensibility of the Void as a language. Each unit can change compiler's state into \"something completely different\"(c)... This feature intendend to be seen as the backdoor to the compiler. You just open the curly brace and enter the compiler as your workshop... This is why these curly braces are magic .</p>"},{"location":"tutorial/#02-the-extended-hello-world-example","title":"0.2. The extended \"Hello, world\" example","text":"<p>Let's try to dig a bit deeper and see how it's possible to declare <code>printf</code> \"from scratch\", without any imports...</p> <pre><code>// Unit 1: declaration of the v_pointer_type\n{\n    typ0 = v_alloca(v_type_ptr, 2);     // Allocate \"array\" for two types\n    typ1 = v_getelementptr(typ0, 1);    // Get pointer to the second element\n\n    v_store(v_type_ptr, typ0);          // Argument 1: element type\n    v_store(unsigned,   typ1);          // Argument 2: address space\n\n    ft = v_function_type(v_type_ptr,    // Return type\n                         typ0,          // Argument types\n                         2,             // Number of arguments\n                         false);        // VarArgs? (not)\n\n    v_add_symbol(\"v_pointer_type\",      // Name\n                 ft,                    // Type\n                 0);                    // Value (none - just declaration)\n}\n\n// Unit 2: declaration of the printf\n{\n    typ = v_alloca(v_type_ptr);\n\n    char_ptr = v_pointer_type(char, 0);\n\n    v_store(char_ptr, typ);             // Format string\n\n    ft = v_function_type(int, typ, 1, true);\n    v_add_symbol(\"printf\", ft, 0);\n}\n\n// Unit 3: call the printf\n{\n    printf(\"Hello, world\\n\");\n}\n</code></pre> <p>First of all, it must be mentioned that when <code>voidc</code> starts to read the source file, it begins with \"minimal\" internal environment. Only very few names are pre-declared. Everything else, that we wish to use, must be declared \"by hands\" (or by imports)...</p> <p>In the case of <code>printf</code> we have almost all necessary tools accessible, except one - the function <code>v_pointer_type</code> (to build \"pointer to char\" type). So, the first unit makes exactly this thing: it declares the <code>v_pointer_type</code> function...</p> <p>As is often the case in programming, it is best to read it sdrawkcab:</p> <ul> <li>The last statement of the unit calls the function <code>v_add_symbol</code> to \"declare\" the <code>v_pointer_type</code> function.   The term \"symbol\" here denotes a symbol in the terminology of (JIT's) linker.</li> </ul> <pre><code>    v_add_symbol(\"v_pointer_type\",      // Name\n                 ft,                    // Type\n                 0);                    // Value (none - just declaration)\n</code></pre> <ul> <li>The last but one statement builds the type of the <code>v_pointer_type</code> function.</li> </ul> <pre><code>    ft = v_function_type(v_type_ptr,    // Return type\n                         typ0,          // Argument types\n                         2,             // Number of arguments\n                         false);        // VarArgs? (not)\n</code></pre> <ul> <li>The previous pair of statements (containing <code>v_store</code>) form the list of argument types for the <code>v_pointer_type</code> function.</li> </ul> <pre><code>    v_store(v_type_ptr, typ0);          // Argument 1: element type\n    v_store(unsigned,   typ1);          // Argument 2: address space\n</code></pre> <ul> <li>And \"finally\", the first couple of statements prepare the memory (in stack) for the list of argument types.</li> </ul> <pre><code>    typ0 = v_alloca(v_type_ptr, 2);     // Allocate \"array\" for two types\n    typ1 = v_getelementptr(typ0, 1);    // Get pointer to the second element\n</code></pre> <p>Many important details have been omitted for brevity...</p> <p>The second unit, in similiar way as the first one, declares the <code>printf</code> function. Note the use of the <code>v_pointer_type</code> function.</p> <pre><code>    typ = v_alloca(v_type_ptr);\n\n    char_ptr = v_pointer_type(char, 0);\n\n    v_store(char_ptr, typ);             // Format string\n\n    ft = v_function_type(int, typ, 1, true);\n    v_add_symbol(\"printf\", ft, 0);\n</code></pre> <p>The third unit just calls the <code>printf</code>...</p> <pre><code>    printf(\"Hello, world\\n\");\n</code></pre>"},{"location":"tutorial/#1-language-syntax-and-semantics","title":"1. Language syntax (and semantics).","text":"<p>In fact, Void as a language has no fixed/constant/static syntax/semantics... Instead, it has a minimalist \"starter language\" and a set of \"language development\" tools. Then the language is developed, and this development is organized into so-called \"levels\".</p> <p>For the moment (Nov 2023) there are four levels:</p> <ul> <li>Level 0.0 - \"Starter Language\" and compiler API.</li> <li>Level 0.1 - Control flow, grammars, expressions and declarations/definitions.</li> <li>Level 0.2 - \"C on steroids\"...</li> <li>Level 0.3 - \"C++ for poors\"...</li> </ul> <p>All these levels together form the so-called \"Mainline Language\".</p> <p>First we'll go over the Starter Language a little. Just to feel \"how it started\". Then we'll take a closer look at the Mainline Language. To find out \"how it's going\"...</p>"},{"location":"tutorial/#2-the-starter-language","title":"2. The Starter Language.","text":""},{"location":"tutorial/#21-syntax-and-a-bit-of-semantics","title":"2.1. Syntax (and a bit of semantics).","text":"<ul> <li>The <code>voidc</code> awaits source files properly encoded in UTF-8.</li> <li>Parser works at a Unicode Code Point \"granularity\".</li> <li>Whitespaces are: <code>' '</code>, <code>'\\t'</code>, <code>'\\n'</code> and <code>'\\r'</code> (in C's notation).</li> <li>Comments are BCPL's <code>//</code> till the end of line.</li> <li>Whitespaces and comments mostly ignored (just delimiters, like in C).</li> </ul> <p>Abstract syntax can be expressed in EBNF-like notation:</p> <pre><code>unit = \"{\" {stmt} \"}\"\n\nstmt = [[ident \"=\"] expr] \";\"\n\nexpr = prim {\"(\" [expr {\",\" expr}] \")\"}\n\nprim = ident | integer | string | char\n</code></pre> <ul> <li>Identifiers are C's: <code>[a-zA-Z_][a-zA-Z_0-9]*</code>, case-sensitive.</li> <li>Integers only decimal, optionaly signed, without leading zeros.</li> <li>Strings and chars similiar to C's, with some \"restrictions\":<ul> <li>Strings are NOT \"auto-concatenable\".</li> <li>Escapes limited only to <code>\\t</code>, <code>\\n</code>, <code>\\r</code>, <code>\\'</code>, <code>\\\"</code> and <code>\\\\</code>.</li> <li>Any other valid non-null Unicode Code Points are allowed.</li> </ul> </li> </ul> <p>So, as you can see, the Starter Language is rather limited:</p> <ul> <li>There are no keywords.</li> <li>There are no operators.</li> <li>There is no arithmetic.</li> <li>There is no flow control.</li> <li>There is no preprocessor.</li> <li>There are no floating-point, hexadecimal, octal or binary literals.</li> <li>Etc, etc, etc ...</li> </ul> <p>How the hell it is possible to program in it?</p> <p>Well... To get an idea you can check the \"hello_jit.void\" example.</p> <p>In Void you must \"write program to write program\"(c)...</p> <p>All the Starter Language really allows is to call functions. Sequentially.</p> <pre><code>printf(\"Hello!\\n\");\nprintf(\"Hello again!\\n\");\nprintf(\"Hello one more time!\\n\");\n</code></pre> <p>Function calls can be nested and \"curried\" (like in C).</p> <pre><code>foo(bar(\"Hi\", 42), '\u042b')(1, 2, 3)(-7);\n</code></pre> <p>What a function returns can be \"named\" by an identifier.</p> <pre><code>n = strlen(\"Some string\");\n</code></pre> <p>These identifiers can be used in subsequent statements.</p> <pre><code>C = '\u042a';\n\nprintf(\"Cyrillic Capital Letter Hard Sign: %d\\n\", C);\n</code></pre> <p>Identifiers also can be \"shadowed\" by subsequent \"renamings\" (like in Rust).</p> <pre><code>u = \"1\";\nu = atof(u);\n\nv = u;\n\nv = fma(v, u, v);\nv = fma(v, u, v);\nv = fma(v, u, v);\nv = fma(v, u, v);\n\nprintf(\"v: %g\\n\", v);\n</code></pre> <p>Please note, in contrast to C, in the Starter Language:</p> <ul> <li>The identifier to the left of the <code>=</code> symbol does NOT denote a variable.</li> <li>The <code>=</code> symbol does NOT denote an assignment.</li> </ul> <p>In fact, the semantics of <code>=</code> in Void is almost the same as in LLVM IR (with respect to \"shadowing\").</p> <p>Informally, it's possible to think of <code>=</code> as a kind of definition operator. It just \"sticks\" a label with the identifier on the left to the value received on the right...</p> <p>Also this is very similar to <code>&lt;-</code> from the monadic \"do\" notation (in Haskell).</p>"},{"location":"tutorial/#22-not-all-functions-are-the-same","title":"2.2. Not all functions are the same...","text":"<p>Let's look at The extended \"Hello, world\" example. In it's code there are several \"function calls\". Some of them actually call real functions (in the \"C\" language sense). But others do \"something different\"...</p> <p>Identifiers <code>v_alloca</code>, <code>v_getelementptr</code> and <code>v_store</code> denote so called \"compile-time intrinsic functions\". Such functions actually called during compilation phase. They take arguments in the form of AST and their purpose is (usually) to generate code...</p> <p>As for the mentioned \"ct-intrinsics\", their semantics correspond to the LLVM IR instructions of similar name.</p> <p>There are number of \"predefined\" compile-time intrinsics, and it's entirely possible to create your own. The main advantage of such functions is that they can be polymorphic in the broadest sense. They can interpret their arguments \"by their own rules\". They can generate code \"in their own way\" and/or change the state of the compiler \"at their discretion\"...</p> <p>Ct-intrinsics are the most widely used \"language development\" tools mentioned above.</p>"},{"location":"tutorial/#23-voids-reserved-names","title":"2.3. Void's Reserved Names","text":"<p>Identifiers starting with <code>v_</code> and <code>voidc_</code> are reserved for the needs of the <code>voidc</code> compiler itself and the (future) standard library...</p> <p>In addition, careless use of external identifiers starting with <code>_</code>, <code>LLVM</code>, etc. can lead to collisions with the C/C++ and LLVM libraries.</p>"},{"location":"tutorial/#24-the-voids-types","title":"2.4. The Void's Types.","text":"<p>Starter Language's typing can be described as static and implicit. This means that the identifier to the left of the <code>=</code> takes the type implicitly determined by the expression on the right. This type does not change during identifier's \"lifetime\" (with respect to \"shadowing\").</p> <p>The Void has it's own type system, which is \"mapped\" to LLVM's one and can be seen as an extension of it...</p> <p>The Starter Language has no specific syntax for types. Therefore, we'll describe Void's type system \"through the lens\" of the compiler's types API. This API is designed to be similar (in spirit) to the LLVM-C API associated with LLVM's types. The implementation of Void's types is also very similar to LLVM's.</p> <p>As you can probably guessed, the name of the type of the Void's types representation is <code>v_type_ptr</code>. Like <code>LLVMTypeRef</code>, <code>v_type_ptr</code> looks like a pointer to some opaque structure.</p>"},{"location":"tutorial/#241-integer-types","title":"2.4.1. Integer types.","text":"<p>Void's integer types are all LLVM's ones with additional \"attribute\" of signedness.</p> <p>Yes! You can use integers of any bitwidth accepted by LLVM (i.e. 1 - 2<sup>23</sup>). And they can also be signed or unsigned.</p> <p>API in \"C\" syntax:</p> <pre><code>v_type_ptr v_int_type(unsigned width);          // Signed\nv_type_ptr v_uint_type(unsigned width);         // Unsigned\n</code></pre> <p>There are number of predefined integral types which correspond to tagret's \"C\" integral types. Some of them: <code>char</code>, <code>short</code>, <code>int</code>, <code>unsigned</code>, <code>long</code>, <code>intptr_t</code> etc...</p> <p>Predefined type <code>bool</code> is the <code>v_uint_type(1)</code>. Named constants <code>false</code> and <code>true</code> have obvious type and values...</p>"},{"location":"tutorial/#242-floating-point-types","title":"2.4.2. Floating point types.","text":"<pre><code>v_type_ptr v_f16_type();            // LLVM's half\nv_type_ptr v_f32_type();            // LLVM's float     - C's\nv_type_ptr v_f64_type();            // LLVM's double    - C's\nv_type_ptr v_f128_type();           // LLVM's fp128\n</code></pre>"},{"location":"tutorial/#243-pointer-types","title":"2.4.3. Pointer types.","text":"<pre><code>v_type_ptr v_pointer_type(v_type_ptr elem, unsigned adsp);\n</code></pre> <p>These pointer types are similar to C's with respect to additional parameter of LLVM's \"address space\"...</p>"},{"location":"tutorial/#244-reference-types","title":"2.4.4. Reference types.","text":"<pre><code>v_type_ptr v_reference_type(v_type_ptr elem, unsigned adsp);\n</code></pre> <p>These references are semantically alike to C++'s <code>&amp;</code> ones (with respect to LLVM's \"address space\").</p> <p>Reference can be seen as a pointer in a \"superhero costume\"... The \"superpower\" of reference is ability to unreference pointed value \"on demand\".</p>"},{"location":"tutorial/#245-array-types","title":"2.4.5. Array types.","text":"<pre><code>v_type_ptr v_array_type(v_type_ptr elem, uint64_t length);\n</code></pre> <p>Ordinary LLVM's (and C's) arrays...</p>"},{"location":"tutorial/#246-vector-types","title":"2.4.6. Vector types.","text":"<pre><code>v_type_ptr v_vector_type(v_type_ptr elem, unsigned size);           // ...\nv_type_ptr v_svector_type(v_type_ptr elem, unsigned size);          // Scalable\n</code></pre> <p>LLVM's vectors...</p>"},{"location":"tutorial/#247-structure-types","title":"2.4.7. Structure types.","text":"<pre><code>v_type_ptr v_struct_type_named(const char *name);                           // Named (opaque)\n\nv_type_ptr v_struct_type(v_type_ptr *elts, unsigned count, bool packed);    // Unnamed\n\nvoid v_type_struct_set_body(v_type_ptr typ, v_type_ptr *elts, unsigned count, bool packed);\n</code></pre> <p>Similar to LLVM's struct types. Fields are unnamed, indexed by numbers...</p>"},{"location":"tutorial/#248-function-types","title":"2.4.8. Function types.","text":"<pre><code>v_type_ptr v_function_type(v_type_ptr ret, v_type_ptr *par, unsigned count, bool vararg);\n</code></pre> <p>Similar to LLVM's (and C's) function types...</p>"},{"location":"tutorial/#249-void-type","title":"2.4.9. Void type.","text":"<pre><code>v_type_ptr v_void_type();               // As is...\n</code></pre> <p>This type also predefined as <code>void</code>...</p>"},{"location":"tutorial/#25-some-notes-on-datatypes-representation","title":"2.5. Some notes on data/types representation ...","text":"<ul> <li> <p><code>'\u044e'</code> - character literals are of type <code>char32_t</code> which is the <code>v_uint_type(32)</code>.</p> </li> <li> <p>String literal represented as a (constant) value of type 'array of <code>char</code>', encoded in UTF-8, null-terminated.</p> </li> </ul> <pre><code>str = \"Hello world!\\n\";         // ... v_array_type(char, 14)\n</code></pre> <ul> <li>Such strings can be promoted to pointers \"on demand\" (like in C):</li> </ul> <pre><code>str = \"world\";\n\nprintf(\"Hello %s!\\n\", str);\n</code></pre> <ul> <li>There's some kind of (C-like) promotion of arithmetic types...</li> </ul> <pre><code>printf(\"sqrt(2) = %g\\n\", sqrt(2));          // C's \"double sqrt(double)\"\n</code></pre>"},{"location":"tutorial/#3-the-mainline-language","title":"3. The Mainline Language.","text":"<p>The \"Mainline Language\" is obtained by applying a sequence of extensions, grouped in the form of so-called \"levels\". Each subsequent extension builds on the previous ones.</p> <p>You can imagine this development as a passage of a computer game. The main character is, in fact, our \u201cLanguage\u201d. At the beginning, he has the \u201crank\u201d of \u201cStarter\u201d and can do almost nothing. But during the game, our hero goes through a whole series of \u201cadventures\u201d and acquires new skills and abilities. And at some point it reaches the \u201crank\u201d of \u201cMainline\u201d...</p> <p>In addition to \u201clevels\u201d there will also be \u201cversions\u201d and they should not be confused. Versions refer to the \"game\" as a whole. The \u201cgame\u201d itself will \u201cevolve\u201d from version to version. The levels will change (slightly) and new levels will be added...</p> <p>There are no versions in our project yet, but at some point they will inevitably appear...</p>"},{"location":"tutorial/#31-how-to-turn-on-mainline-language","title":"3.1. How to \"turn on\" Mainline Language.","text":"<p>The simplest (but not the only) way is to place these two units at the beginning of the source file:</p> <pre><code>{ v_import(\"mainline.void\"); }      // Import the Mainline Language\n{ v_enable_mainline(); }            // \"Enable\" it\n</code></pre> <p>The first unit imports all the necessary tools for the Mainline Language to work, but the current language does not change. The import process will compile quite a lot of code for the first time, which can take quite a long time. But subsequent imports will be significantly faster thanks to \"pre-compilation\" (Python style)...</p> <p>The second unit calls the <code>v_enable_mainline</code> function, imported from <code>mainline.void</code>. This function \"enables\" all the tools of the Mainline Language:</p> <ul> <li>Changes the grammar (and parser).</li> <li>Adds new \u201cnode types\u201d to the AST hierarchy.</li> <li>\"Teaches\" the compiler to work with these new types of AST nodes.</li> </ul> <p>As a result, immediately after the second unit (right after its <code>}</code>) the \u201cnew compiler\u201d of Mainline Language starts working, which allows you to use all the new features...</p>"},{"location":"tutorial/#32-the-most-important-innovations","title":"3.2. The most important innovations:","text":"<ul> <li>A new kind of units containing a set of definitions/declarations.</li> <li>A new kind of \u201cstatements\u201d - definitions and declarations.</li> </ul> <p>Example (assuming Mainline Language is already enabled):</p> <pre><code>// ...\n// Unit of definitions/declarations:\n\ndouble = float(64);             // Kinda, \"typedef\"\n\nceil: (double) ~&gt; double;       // Declarations...\nsqrt: (double) ~&gt; double;\n\nprintf: (*const char, ...) ~&gt; int;          // Good old printf...\n\nS = 1000;                       // Size of sieve - constant, int type\n\nsieve: &amp;bool[S] := 0;           // Mutable array of bool, zero initialized\n\n// \"Usual\" unit:\n{\n    sieve[2] := true;           // Assignment ...\n\n    for (i: &amp;int := 3; i &lt; S; i += 2)   sieve[i] := true;\n\n    R = (ceil(sqrt(S)) : int);      // ... cast ...\n\n    for (i: &amp;int := 3; i &lt; R; i += 2)\n    {\n        if (!sieve[i])  continue;\n\n        for (k: &amp;int := i*i, i2 = 2*i; k &lt; S; k += i2)\n        {\n            sieve[k] := false;\n        }\n    }\n\n    for (i: &amp;int := 0; i &lt; S; ++i)\n    {\n        if (sieve[i])  printf(\"%d\\n\", i);\n    }\n}\n</code></pre> <p>In this example you can see two units:</p> <ul> <li>The first, in a new format, contains definitions and declarations.</li> <li>The second, in familiar braces, contains many new constructions...</li> </ul> <p>New kind units usually occupy all the space between two \"traditional\" units and must contain at least one definition or declaration. Let's see what we have there:</p> <ul> <li>Definition of the type <code>double</code>, in a familiar style. And yes, we now have type expression syntax!</li> <li>Declarations of some C functions. In a \"mathematical\" style. The <code>~&gt;</code> operator \"hints\" that these are imperative functions. Parentheses around the parameter list are mandatory.</li> <li>Definition of an integer constant. The default type is <code>int</code>. If you need something else, please indicate explicitly, for example: <code>Sz: size_t = 65536;</code></li> <li>Definition of a mutable variable. The type must be reference. The <code>:=</code> operator means initialization. If you omit the initialization and leave only the type, you get a declaration...</li> </ul> <p>All the above definitions/declarations are global and are visible in all subsequent units. The order is important! Every identifier must be defined or declared before it can be used.</p> <p>Now let's see what's interesting in the second unit:</p> <ul> <li> <p>Expressions in C style with some features:</p> <ul> <li>The assignment operator symbol looks like <code>:=</code> (same as initialization).</li> <li>The cast operator looks like <code>( &lt;value&gt; : &lt;type&gt; )</code>. Parentheses are mandatory.</li> <li>For other details of the expressions, see below...</li> </ul> </li> <li> <p>C-style flow control constructs:</p> <ul> <li><code>for</code> loop with some C++ style tricks.</li> <li>Quite familiar <code>if</code>.</li> <li>More details on flow control below...</li> </ul> </li> </ul>"},{"location":"tutorial/#33-definitions-and-declarations","title":"3.3. Definitions and declarations.","text":"<p>These \"statements\" are of two kinds:</p>"},{"location":"tutorial/#331-definitions","title":"3.3.1. Definitions.","text":"<p>Usually contains <code>=</code> or <code>:=</code> operators.</p>"},{"location":"tutorial/#3311-defining-constants","title":"3.3.1.1. Defining constants.","text":"<p>Syntax - <code>&lt;name&gt; : &lt;type&gt; = &lt;value&gt; ;</code> or the familiar <code>&lt;name&gt; = &lt;expression&gt; ;</code>:</p> <ul> <li><code>&lt;name&gt;</code> can be an identifier or a so-called special identifier.</li> <li><code>&lt;type&gt;</code> and <code>&lt;value&gt;</code> are usually expressions.</li> <li><code>&lt;expression&gt;</code> can denote a type.</li> </ul> <p>Example:</p> <pre><code>U = 'U';                                    // U : char32_t\n\ns = \"Hello World\";                          // s : char[12]\n\nf = s[6] == U+2;                            // Same as  f = true;\n\nss: (*const char)[] = { \"foo\", s+6 };       // ss : (*const char)[2]\n\ntt = ss[f];                                 // tt : *const char\n\n{ printf(\"Hello %s!\\n\", tt); }              // ...\n</code></pre>"},{"location":"tutorial/#3312-defining-variables","title":"3.3.1.2. Defining variables.","text":"<p>Syntax - <code>&lt;name&gt; : &lt;type&gt; := &lt;value&gt; ;</code>:</p> <ul> <li><code>&lt;name&gt;</code> is the usual identifier of a variable located in memory.</li> <li><code>&lt;type&gt;</code> is an expression that must denote a reference type.</li> <li> <p><code>&lt;value&gt;</code> is an expression that specifies the initial value. Special (universal) cases:</p> <ul> <li><code>0</code> - zero initialization.</li> <li><code>undef</code> - the initial value is undefined.</li> </ul> </li> </ul> <p>Example:</p> <pre><code>i: &amp;int := 1;                               // Just int\n\nj: &amp;int[5] := { i+0, i+1, i+2, i+3, i+4 };  // Array of ints\n\nk: &amp;(*int)[3] := { j+0, j+1, j+2 };         // Array of pointers\n\nf = j[2] == 3;                              // Almost the same as  f = true;\n\ng = k[2] == &amp;j[2];                          // Almost the same as  g = true;\n</code></pre>"},{"location":"tutorial/#3313-defining-functions","title":"3.3.1.3. Defining functions.","text":"<p>Syntax - <code>&lt;name&gt; : &lt;type&gt; { &lt;body&gt; }</code>:</p> <ul> <li><code>&lt;name&gt;</code> can be an identifier or a so-called special identifier.</li> <li><code>&lt;type&gt;</code> is an \"expression\" that must denote a function proto-type.</li> <li><code>&lt;body&gt;</code> - list of statements...</li> </ul> <p>Example:</p> <pre><code>multiply: (a: int, b: int) ~&gt; int           // By value\n{\n    return  a * b;                          // ...\n}\n</code></pre>"},{"location":"tutorial/#3314-defining-structunion-types-with-named-fields","title":"3.3.1.4. Defining struct/union types with named fields.","text":"<p>Syntax (in EBNF-like notation):</p> <pre><code>... = (\"struct\"|\"union\") [identifier] ['{' {[identifier ':'] expression ';'} '}'] ';'\n</code></pre> <p>Structures and unions are in many ways similar to C ones. See details below.</p> <p>Example:</p> <pre><code>struct FILE;            // Opaque structure\n\nstruct Coords\n{\n    x: double;\n    y: double;\n};\n\nbyte = uint(8);\n\nunion IntRep\n{\n    i: int;\n    r: byte[int.sizeof];\n};\n\n{   ir: &amp;IntRep := undef;\n\n    ir.i := 0xDEADBEEF;\n\n    for (i: &amp;int := 0; i &lt; int.sizeof; ++i)\n    {\n        printf(\"%02X \", ir.r[i]);\n    }\n\n    printf(\"\\n\");\n}\n</code></pre>"},{"location":"tutorial/#332-declarations","title":"3.3.2. Declarations.","text":"<p>General syntax - <code>&lt;name&gt; : &lt;type&gt; ;</code>:</p> <ul> <li><code>&lt;name&gt;</code> can be an identifier or a so-called special identifier.</li> <li><code>&lt;type&gt;</code> is a type expression.</li> </ul> <p>Depending on what <code>&lt;type&gt;</code> is, different cases are possible...</p>"},{"location":"tutorial/#3321-function-declarations","title":"3.3.2.1. Function declarations.","text":"<p><code>&lt;type&gt;</code> must be a function type.</p> <p>Example:</p> <pre><code>qsort: (ptr: *void, cn: size_t, sz: size_t, cmp: *((*const void, *const void) ~&gt; int)) ~&gt; void;\n\ncompare: (a: *const void, b: *const void) ~&gt; int\n{\n    a = *(a: *const int);\n    b = *(b: *const int);\n\n    return  a - b;\n}\n\n{   ints: &amp;int[] := { 0, 4, 2, 3, 1 };\n\n    qsort(ints, 5, int.sizeof, compare);\n\n    for (i: &amp;int := 0; i &lt; 5; ++i)  printf(\"%d \", ints[i]);\n\n    printf(\"\\n\");\n}\n</code></pre>"},{"location":"tutorial/#3322-variable-declarations","title":"3.3.2.2. Variable declarations.","text":"<p><code>&lt;type&gt;</code> must be a reference type.</p> <p>Example:</p> <pre><code>struct FILE;                    // Definition of opaque structure type\n\nstdin:  &amp;*FILE;                 // Declarations of C's stdio streams\nstdout: &amp;*FILE;                 // ...\nstderr: &amp;*FILE;                 // ...\n\nfprintf: (*FILE, *const char, ...) ~&gt; int;\n\n(_.printf()) = fprintf;         // Definition of a \"special identifier\" for fprintf.\n\n{   fprintf(stdout, \"Hello!\\n\");\n\n    stdout.printf(\"Hello %s...\\n\", \"again\");\n}\n</code></pre>"},{"location":"tutorial/#3323-constant-declarations","title":"3.3.2.3. Constant declarations.","text":"<p>For now (Dec 2023) this is a very experimental case...</p> <p>...</p>"},{"location":"tutorial/#34-expressions","title":"3.4. Expressions.","text":"<p>...</p> <p>...</p>"},{"location":"tutorial/#to-be-continued","title":"To be continued...","text":""}]}